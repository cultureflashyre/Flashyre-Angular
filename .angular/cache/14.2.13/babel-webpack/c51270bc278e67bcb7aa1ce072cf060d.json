{"ast":null,"code":"import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n  str = unescape(encodeURIComponent(str));\n  const bytes = new Uint8Array(str.length);\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes[i] = str.charCodeAt(i);\n  }\n\n  return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n  const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n  const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n\n  if (typeof namespace === 'string') {\n    namespace = parse(namespace);\n  }\n\n  if (namespace?.length !== 16) {\n    throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n  }\n\n  let bytes = new Uint8Array(16 + valueBytes.length);\n  bytes.set(namespaceBytes);\n  bytes.set(valueBytes, namespaceBytes.length);\n  bytes = hash(bytes);\n  bytes[6] = bytes[6] & 0x0f | version;\n  bytes[8] = bytes[8] & 0x3f | 0x80;\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = bytes[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(bytes);\n}","map":null,"metadata":{},"sourceType":"module"}