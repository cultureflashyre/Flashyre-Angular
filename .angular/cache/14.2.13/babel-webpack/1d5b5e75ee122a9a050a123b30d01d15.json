{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { ContentChild, Input, Component } from '@angular/core';\nlet FlashyreAssessment = class FlashyreAssessment {\n  constructor(title, meta, assessmentService, trialAssessmentService, videoRecorder, proctoringService, router, spinner, route) {\n    this.title = title;\n    this.meta = meta;\n    this.assessmentService = assessmentService;\n    this.trialAssessmentService = trialAssessmentService;\n    this.videoRecorder = videoRecorder;\n    this.proctoringService = proctoringService;\n    this.router = router;\n    this.spinner = spinner;\n    this.route = route;\n    this.logoSrc = '/assets/main-logo/logo%20-%20flashyre(1500px)-200h.png';\n    this.rootClassName = '';\n    this.logoAlt = 'image';\n    this.isTrialAssessment = false; // Flag to determine which service to use\n\n    this.currentQuestionIndex = 0;\n    this.currentSectionIndex = 0;\n    this.isLastQuestionInSection = false; // Assessment data\n\n    this.assessmentData = {};\n    this.currentQuestions = [];\n    this.currentQuestion = {}; // Current question being displayed\n\n    this.currentOptions = []; // Options for current question\n\n    this.sectionTimer = 0; // User data\n\n    this.userId = 1;\n    this.selectedAnswers = {};\n    this.questionStates = {};\n    this.userResponses = {}; // For binding to UI elements\n\n    this.title.setTitle('Flashyre Assessment - Flashyre');\n    this.meta.addTags([{\n      property: 'og:title',\n      content: 'Flashyre Assessment - Flashyre'\n    }, {\n      property: 'og:image',\n      content: 'https://aheioqhobo.cloudimg.io/v7/_playground-bucket-v2.teleporthq.io_/8203932d-6f2d-4493-a7b2-7000ee521aa2/9aea8e9c-27ce-4011-a345-94a92ae2dbf8?org_if_sml=1&force_format=original'\n    }]);\n  }\n\n  ngOnInit() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Extract assessmentId from query parameters\n      const assessmentId = this.route.snapshot.queryParamMap.get('id');\n\n      if (assessmentId) {\n        this.fetchAssessmentData(+assessmentId); // Convert to number and fetch data\n\n        this.startTime = new Date(); // Record start time when assessment begins\n\n        try {\n          yield this.videoRecorder.startRecording();\n          this.proctoringService.startMonitoring();\n        } catch (error) {\n          console.error('Failed to start assessment:', error);\n        }\n      } else {\n        console.error('No assessment ID provided in route');\n        this.router.navigate(['/assessment-error']); // Redirect if no ID\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    if (this.timerSubscription) {\n      this.timerSubscription.unsubscribe();\n    }\n\n    clearInterval(this.timerInterval);\n    clearInterval(this.sectionTimerInterval);\n  }\n\n  fetchAssessmentData(assessmentId) {\n    this.spinner.show(); // Choose which service to use based on assessment type\n\n    const service = this.isTrialAssessment ? this.trialAssessmentService.getAssessmentDetails(assessmentId) : this.assessmentService.getAssessmentData(assessmentId);\n    service.subscribe({\n      next: data => {\n        console.log('Raw API response:', data);\n        this.assessmentData = data;\n        this.sections = Object.keys(data.sections).map(sectionName => Object.assign({\n          name: sectionName\n        }, data.sections[sectionName]));\n        console.log('Processed sections:', this.sections);\n        this.totalSections = this.sections.length;\n        this.timer = data.total_assessment_duration * 60; // Update timer in appropriate service\n\n        if (this.isTrialAssessment) {\n          this.trialAssessmentService.updateTimer(this.timer);\n        } else {\n          this.assessmentService.updateTimer(this.timer);\n        }\n\n        this.startTimer();\n        this.selectSection(this.sections[0]);\n      },\n      error: error => {\n        console.error('Error fetching assessment data:', error);\n      },\n      complete: () => {\n        this.spinner.hide();\n      }\n    });\n  }\n\n  startTimer() {\n    // Subscribe to timer from appropriate service\n    const timerObservable = this.isTrialAssessment ? this.trialAssessmentService.timer$ : this.assessmentService.timer$;\n    this.timerSubscription = timerObservable.subscribe(time => {\n      this.timer = time;\n\n      if (this.timer <= 0) {\n        this.terminateTest();\n      }\n    });\n    this.decrementTimer();\n  }\n\n  decrementTimer() {\n    this.timerInterval = setInterval(() => {\n      if (this.timer > 0) {\n        // Update timer in appropriate service\n        if (this.isTrialAssessment) {\n          this.trialAssessmentService.updateTimer(this.timer - 1);\n        } else {\n          this.assessmentService.updateTimer(this.timer - 1);\n        }\n      } else {\n        clearInterval(this.timerInterval);\n      }\n    }, 1000);\n  }\n\n  startSectionTimer() {\n    if (this.sectionTimerInterval) {\n      clearInterval(this.sectionTimerInterval);\n    } // Only start section timer if section has a duration\n\n\n    if (this.currentSection && this.currentSection.duration) {\n      this.sectionTimer = this.currentSection.duration * 60;\n      this.sectionTimerInterval = setInterval(() => {\n        if (this.sectionTimer > 0) {\n          this.sectionTimer--;\n        } else {\n          clearInterval(this.sectionTimerInterval);\n          this.sectionTimerInterval = null; // Optional: Auto-move to next section\n\n          if (!this.isLastSection) {\n            this.nextSection();\n          }\n        }\n      }, 1000);\n    }\n  }\n\n  selectSection(section) {\n    this.currentSection = section;\n    this.currentSectionIndex = this.sections.indexOf(section);\n    this.currentQuestions = section.questions;\n    this.currentQuestionIndex = 0;\n    this.totalQuestionsInSection = this.currentQuestions.length;\n    this.isLastSection = this.currentSectionIndex === this.totalSections - 1;\n    this.updateCurrentQuestion();\n    this.startSectionTimer();\n  }\n\n  updateCurrentQuestion() {\n    if (this.currentQuestions && this.currentQuestions.length > 0) {\n      this.currentQuestion = this.currentQuestions[this.currentQuestionIndex];\n      this.updateCurrentOptions();\n      this.checkIfLastQuestionInSection();\n      this.markQuestionAsVisited(this.currentQuestionIndex);\n    } else {\n      this.currentQuestion = {\n        question: 'No questions available'\n      };\n      this.currentOptions = [];\n    }\n  }\n\n  updateCurrentOptions() {\n    if (this.currentQuestion && this.currentQuestion.options) {\n      this.currentOptions = this.getOptions(this.currentQuestion);\n    } else {\n      this.currentOptions = [];\n    }\n  }\n\n  checkIfLastQuestionInSection() {\n    this.isLastQuestionInSection = this.currentQuestionIndex === this.currentQuestions.length - 1;\n  }\n\n  getOptions(question) {\n    if (!question || !question.options) return []; // Handle different option formats\n\n    if (question.option_type !== undefined) {\n      // Format from the first component\n      const options = Object.keys(question.options).map(key => ({\n        key,\n        text: question.options[key],\n        image: null // First component doesn't handle option images\n\n      }));\n      return question.option_type === 2 ? options.slice(0, 2) : options.slice(0, 4);\n    } else {\n      // Format from the second component\n      const options = [];\n\n      for (let i = 1; i <= 4; i++) {\n        const key = `option${i}`;\n        const imageKey = `option${i}_image`;\n\n        if (question.options[key]) {\n          options.push({\n            key: key,\n            text: question.options[key],\n            image: question.options[imageKey] || null\n          });\n        }\n      }\n\n      return options;\n    }\n  }\n\n  markQuestionAsVisited(index) {\n    if (!this.questionStates[index]) {\n      this.questionStates[index] = 'visited';\n    }\n  }\n\n  markQuestionAsAnswered(index) {\n    if (this.questionStates[index] === 'visited' || !this.questionStates[index]) {\n      this.questionStates[index] = 'answered';\n    }\n  }\n\n  navigateToQuestion(index) {\n    if (index >= 0 && index < this.currentQuestions.length) {\n      this.currentQuestionIndex = index;\n      this.updateCurrentQuestion();\n    }\n  } // Alias for template usage\n\n\n  goToQuestion(index) {\n    this.navigateToQuestion(index);\n  }\n\n  selectOption(questionId, sectionId, answer) {\n    this.selectedAnswers[questionId] = {\n      answer: answer,\n      section_id: sectionId\n    };\n    this.markQuestionAsAnswered(this.currentQuestionIndex);\n  }\n\n  onOptionSelected(questionId, sectionId, answer) {\n    this.selectOption(questionId, sectionId, answer);\n  }\n\n  clearResponse(questionId) {\n    // Clear from userResponses (UI binding)\n    if (this.userResponses.hasOwnProperty(questionId)) {\n      delete this.userResponses[questionId];\n    } // Clear from selectedAnswers (submission data)\n\n\n    if (this.selectedAnswers.hasOwnProperty(questionId)) {\n      delete this.selectedAnswers[questionId];\n    } // Update question state\n\n\n    const questionIndex = this.currentQuestions.findIndex(q => q.question_id === questionId);\n\n    if (questionIndex !== -1 && this.questionStates[questionIndex] === 'answered') {\n      this.questionStates[questionIndex] = 'visited';\n    }\n  }\n\n  terminateTest() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.videoRecorder.stopRecording();\n        this.proctoringService.stopMonitoring();\n        this.videoPath = yield this.videoRecorder.getVideoPath();\n        const responses = this.prepareSubmissionData(); // Submit to appropriate service\n\n        const submissionService = this.isTrialAssessment ? this.trialAssessmentService.submitAssessment(responses) : this.assessmentService.submitAssessment(responses);\n        submissionService.subscribe({\n          next: response => {\n            console.log('Assessment submitted successfully:', response);\n            this.router.navigate(['/candidate-dashboard-main']);\n          },\n          error: error => {\n            console.error('Assessment submission failed:', error);\n            this.router.navigate(['/assessment-error']);\n          }\n        });\n      } catch (error) {\n        console.error('Termination failed:', error);\n        this.router.navigate(['/assessment-error']);\n      }\n    });\n  } // Alias for template usage\n\n\n  endTest() {\n    this.terminateTest();\n  }\n\n  prepareSubmissionData() {\n    return {\n      assessmentId: this.assessmentData.assessment_id,\n      userId: this.userId,\n      responses: Object.keys(this.selectedAnswers).map(questionId => ({\n        questionId: +questionId,\n        sectionId: this.selectedAnswers[+questionId].section_id,\n        answer: this.selectedAnswers[+questionId].answer\n      })),\n      startTime: this.startTime,\n      endTime: new Date().toISOString(),\n      submissionType: 'manual',\n      videoPath: this.videoPath\n    };\n  }\n\n  previousQuestion() {\n    if (this.currentQuestionIndex > 0) {\n      this.currentQuestionIndex--;\n      this.updateCurrentQuestion();\n    }\n  }\n\n  nextQuestion() {\n    if (this.currentQuestionIndex < this.currentQuestions.length - 1) {\n      this.currentQuestionIndex++;\n      this.updateCurrentQuestion();\n    }\n  }\n\n  nextSection() {\n    if (this.currentSectionIndex < this.totalSections - 1) {\n      this.currentSectionIndex++;\n      this.selectSection(this.sections[this.currentSectionIndex]);\n    }\n  } // Helper methods for template rendering\n\n\n  hasQuestionImage(question) {\n    return question && question.question_image && question.question_image.trim() !== '';\n  }\n\n  hasOptionImage(option) {\n    return option && option.image && option.image.trim() !== '';\n  }\n\n  isValidImage(url) {\n    return url && (url.startsWith('http://') || url.startsWith('https://'));\n  }\n\n  handleImageError(event) {\n    console.warn('Image failed to load:', event.target.src);\n    event.target.style.display = 'none'; // Hide broken image\n  } // Helper method for time formatting\n\n\n  formatTime(seconds) {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;\n  }\n\n};\n\n__decorate([ContentChild('endTestText')], FlashyreAssessment.prototype, \"endTestText\", void 0);\n\n__decorate([Input()], FlashyreAssessment.prototype, \"logoSrc\", void 0);\n\n__decorate([Input()], FlashyreAssessment.prototype, \"rootClassName\", void 0);\n\n__decorate([Input()], FlashyreAssessment.prototype, \"logoAlt\", void 0);\n\n__decorate([Input()], FlashyreAssessment.prototype, \"isTrialAssessment\", void 0);\n\nFlashyreAssessment = __decorate([Component({\n  selector: 'flashyre-assessment',\n  templateUrl: 'flashyre-assessment.component.html',\n  styleUrls: ['flashyre-assessment.component.css']\n})], FlashyreAssessment);\nexport { FlashyreAssessment };","map":null,"metadata":{},"sourceType":"module"}