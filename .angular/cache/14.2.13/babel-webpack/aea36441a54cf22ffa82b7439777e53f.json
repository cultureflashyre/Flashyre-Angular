{"ast":null,"code":"// src/app/components/create-job-post-1st-page/create-job-post-1st-page.component.ts\nimport { __decorate } from \"tslib\";\nimport { Component, ViewChild } from '@angular/core';\nimport { Validators } from '@angular/forms'; // Added FormArray\n\nimport { Subject } from 'rxjs'; // Added Subscription\n\nimport { debounceTime, distinctUntilChanged, switchMap, takeUntil } from 'rxjs/operators'; // Added takeUntil\n\nlet CreateJobPost1stPageComponent = class CreateJobPost1stPageComponent {\n  constructor(title, meta, fb, snackBar, jobDescriptionService, corporateAuthService, router, route) {\n    this.title = title;\n    this.meta = meta;\n    this.fb = fb;\n    this.snackBar = snackBar;\n    this.jobDescriptionService = jobDescriptionService;\n    this.corporateAuthService = corporateAuthService;\n    this.router = router;\n    this.route = route;\n    this.searchTerms = new Subject();\n    this.componentDestroyed$ = new Subject(); // For unsubscribing\n\n    this.suggestions = [];\n    this.isLoadingLocation = false; // Renamed for clarity\n\n    this.showLocationSuggestions = false; // Renamed for clarity\n\n    this.selectedFile = null;\n    this.DEBOUNCE_DELAY = 300;\n    this.currentStep = 'jobPost';\n    this.isSubmitting = false; // From new code, good practice\n    // This can be simplified if populateForm doesn't rely on ViewChild elements being ready for patchValue\n\n    this.jobDataToLoad = null;\n    this.isViewInitialized = false; // For skills tag input (managed by initializeSkillsInput)\n\n    this.availableSkills = ['JavaScript', 'HTML', 'CSS', 'React', 'Vue', 'Angular', 'Node.js', 'TypeScript', 'Python', 'Java', 'PHP', 'Ruby', 'Swift', 'Kotlin', 'Go', 'Rust', 'C#', 'C++', 'MongoDB', 'MySQL', 'PostgreSQL', 'Redis', 'GraphQL', 'REST API', 'Machine Learning', 'Artificial Intelligence', 'Data Science', 'Cloud Computing', 'AWS', 'Azure', 'Google Cloud Platform', 'DevOps', 'CI/CD', 'Docker', 'Kubernetes', 'Cybersecurity', 'Blockchain', 'Mobile Development', 'Frontend Development', 'Backend Development', 'Full-stack Development', 'UI/UX Design', 'QA Testing', 'Agile Methodologies', 'Scrum', 'Project Management'];\n    this.activeSkillSuggestionIndex = -1;\n    this.jobForm = this.fb.group({\n      unique_id: [null],\n      role: ['', [Validators.required, Validators.maxLength(100)]],\n      location: ['', [Validators.required, Validators.maxLength(200)]],\n      job_type: ['', [Validators.required, Validators.maxLength(50)]],\n      workplace_type: ['', [Validators.required, Validators.maxLength(50)]],\n      total_experience_min: [0, [Validators.required, Validators.min(0), Validators.max(30)]],\n      total_experience_max: [30, [Validators.required, Validators.min(0), Validators.max(30)]],\n      relevant_experience_min: [0, [Validators.required, Validators.min(0), Validators.max(30)]],\n      relevant_experience_max: [30, [Validators.required, Validators.min(0), Validators.max(30)]],\n      budget_type: ['', [Validators.required, Validators.maxLength(50)]],\n      min_budget: [null, [Validators.required, Validators.min(0)]],\n      max_budget: [null, [Validators.required, Validators.min(0)]],\n      notice_period: ['', [Validators.required, Validators.maxLength(50)]],\n      skills: this.fb.array([], Validators.required),\n      job_description: ['', [Validators.required, Validators.maxLength(5000)]],\n      job_description_url: ['', [Validators.maxLength(200)]],\n      status: ['draft', Validators.required] // From new code\n\n    }, {\n      validators: this.experienceAndBudgetRangeValidator\n    }); // Renamed validator\n  }\n\n  ngOnInit() {\n    this.title.setTitle('Create Job Post - Flashyre');\n    this.meta.addTags([{\n      property: 'og:title',\n      content: 'Create Job Post - Flashyre'\n    }, {\n      property: 'og:image',\n      content: 'https://aheioqhobo.cloudimg.io/v7/_playground-bucket-v2.teleporthq.io_/8203932d-6f2d-4493-a7b2-7000ee521aa2/9aea8e9c-27ce-4011-a345-94a92ae2dbf8?org_if_sml=1&force_format=original'\n    }]);\n\n    if (!this.corporateAuthService.isLoggedIn()) {\n      this.snackBar.open('Please log in to create a job post.', 'Close', {\n        duration: 5000\n      });\n      this.router.navigate(['/login-corporate']);\n      return;\n    }\n\n    this.setupLocationSearch();\n    const uniqueIdFromRoute = this.route.snapshot.paramMap.get('unique_id');\n\n    if (uniqueIdFromRoute) {\n      this.loadJobPostData(uniqueIdFromRoute);\n    }\n  }\n\n  ngAfterViewInit() {\n    this.isViewInitialized = true;\n\n    if (this.jobDataToLoad) {\n      // If data was fetched before view init, populate form now\n      // This ensures editor and other UI elements are ready for setJobDescription etc.\n      this.processAndPopulateForm(this.jobDataToLoad);\n      this.jobDataToLoad = null; // Clear it after loading\n    } // Initialize UI elements that depend on the view\n\n\n    this.initializeSkillsInput();\n    this.initializeExperienceRangeSlider('total');\n    this.initializeExperienceRangeSlider('relevant');\n    this.updateExperienceSlidersUI(); // Initial UI state for sliders\n    // Initialize the job description editor (if it needs specific JS init)\n\n    this.checkEditorPlaceholder('editor'); // Check placeholder for editor\n  }\n\n  ngOnDestroy() {\n    this.componentDestroyed$.next();\n    this.componentDestroyed$.complete(); // Consider removing document event listeners added in initializeExperienceRangeSlider and initializeSkillsInput\n    // For brevity, not explicitly shown here but important for preventing memory leaks.\n  } // --- Form Accessors ---\n\n\n  get skillsFormArray() {\n    return this.jobForm.get('skills');\n  } // --- Validator ---\n\n\n  experienceAndBudgetRangeValidator(form) {\n    var _a, _b, _c, _d, _e, _f;\n\n    const totalMin = (_a = form.get('total_experience_min')) === null || _a === void 0 ? void 0 : _a.value;\n    const totalMax = (_b = form.get('total_experience_max')) === null || _b === void 0 ? void 0 : _b.value;\n    const relevantMin = (_c = form.get('relevant_experience_min')) === null || _c === void 0 ? void 0 : _c.value;\n    const relevantMax = (_d = form.get('relevant_experience_max')) === null || _d === void 0 ? void 0 : _d.value;\n    const minBudget = (_e = form.get('min_budget')) === null || _e === void 0 ? void 0 : _e.value;\n    const maxBudget = (_f = form.get('max_budget')) === null || _f === void 0 ? void 0 : _f.value;\n    let errors = {};\n\n    if (totalMin > totalMax) {\n      errors = Object.assign(Object.assign({}, errors), {\n        invalidTotalExperience: true\n      });\n    }\n\n    if (relevantMin > relevantMax) {\n      errors = Object.assign(Object.assign({}, errors), {\n        invalidRelevantExperience: true\n      });\n    }\n\n    if (minBudget !== null && maxBudget !== null && minBudget > maxBudget) {\n      errors = Object.assign(Object.assign({}, errors), {\n        invalidBudgetRange: true\n      });\n    }\n\n    return Object.keys(errors).length ? errors : null;\n  } // --- Data Loading and Population ---\n\n\n  loadJobPostData(uniqueId) {\n    const token = this.corporateAuthService.getJWTToken();\n\n    if (!token) {\n      this.snackBar.open('Authentication error. Please log in again.', 'Close', {\n        duration: 5000\n      });\n      this.router.navigate(['/login-corporate']);\n      return;\n    } // Assuming getJobPost from JobDescriptionService expects uniqueId and token\n\n\n    this.jobDescriptionService.getJobPost(uniqueId, token).pipe(takeUntil(this.componentDestroyed$)).subscribe({\n      next: jobPost => {\n        if (this.isViewInitialized) {\n          this.processAndPopulateForm(jobPost);\n        } else {\n          this.jobDataToLoad = jobPost; // Store data to populate in AfterViewInit\n        }\n\n        this.snackBar.open('Job post data loaded successfully.', 'Close', {\n          duration: 3000\n        });\n      },\n      error: error => {\n        this.snackBar.open(`Failed to load job post: ${error.message || 'Unknown error'}`, 'Close', {\n          duration: 5000\n        });\n        console.error('Error fetching job post:', error);\n      }\n    });\n  }\n\n  processAndPopulateForm(jobData) {\n    var _a, _b, _c;\n\n    let formData;\n\n    if ('job_details' in jobData) {\n      // This is AIJobResponse\n      const aiJobData = jobData;\n      const jobDetails = aiJobData.job_details;\n      const [minExp, maxExp] = this.parseExperienceRange(((_a = jobDetails.experience) === null || _a === void 0 ? void 0 : _a.value) || '0-0 years');\n      formData = {\n        role: ((_b = jobDetails.job_titles[0]) === null || _b === void 0 ? void 0 : _b.value) || '',\n        location: jobDetails.location || '',\n        job_type: this.mapJobTypeFromTitle(((_c = jobDetails.job_titles[0]) === null || _c === void 0 ? void 0 : _c.value) || ''),\n        workplace_type: jobDetails.workplace_type || 'Remote',\n        total_experience_min: minExp,\n        total_experience_max: maxExp,\n        relevant_experience_min: minExp,\n        relevant_experience_max: maxExp,\n        budget_type: jobDetails.budget_type || 'Annually',\n        min_budget: jobDetails.min_budget || null,\n        max_budget: jobDetails.max_budget || null,\n        notice_period: jobDetails.notice_period || '30 days',\n        skills: [...(jobDetails.skills.primary || []).map(s => s.skill), ...(jobDetails.skills.secondary || []).map(s => s.skill)],\n        job_description: jobDetails.job_description || '',\n        unique_id: aiJobData.unique_id,\n        job_description_url: aiJobData.file_url,\n        status: 'draft' // Default status or from data if available\n\n      };\n    } else {\n      // This is JobDetailsModel\n      const jobDetails = jobData;\n      formData = {\n        role: jobDetails.role,\n        location: jobDetails.location,\n        job_type: jobDetails.job_type,\n        workplace_type: jobDetails.workplace_type,\n        total_experience_min: jobDetails.total_experience_min,\n        total_experience_max: jobDetails.total_experience_max,\n        relevant_experience_min: jobDetails.relevant_experience_min,\n        relevant_experience_max: jobDetails.relevant_experience_max,\n        budget_type: jobDetails.budget_type,\n        min_budget: jobDetails.min_budget,\n        max_budget: jobDetails.max_budget,\n        notice_period: jobDetails.notice_period,\n        // Skills in JobDetailsModel might be { primary: SkillDetail[], secondary: SkillDetail[] }\n        skills: [...(jobDetails.skills.primary || []).map(s => typeof s === 'string' ? s : s.skill), ...(jobDetails.skills.secondary || []).map(s => typeof s === 'string' ? s : s.skill)],\n        job_description: jobDetails.job_description,\n        unique_id: jobDetails.unique_id,\n        // job_description_url: jobDetails.job_description_url, // If JobDetailsModel has this\n        status: jobDetails.status || 'draft'\n      };\n    } // Adjust experience ranges after parsing\n\n\n    [formData.total_experience_min, formData.total_experience_max] = this.adjustExperienceValues(formData.total_experience_min, formData.total_experience_max);\n    [formData.relevant_experience_min, formData.relevant_experience_max] = this.adjustExperienceValues(formData.relevant_experience_min, formData.relevant_experience_max);\n    this.jobForm.patchValue({\n      unique_id: formData.unique_id,\n      role: formData.role,\n      location: formData.location,\n      job_type: formData.job_type,\n      workplace_type: formData.workplace_type,\n      total_experience_min: formData.total_experience_min,\n      total_experience_max: formData.total_experience_max,\n      relevant_experience_min: formData.relevant_experience_min,\n      relevant_experience_max: formData.relevant_experience_max,\n      budget_type: formData.budget_type,\n      min_budget: formData.min_budget,\n      max_budget: formData.max_budget,\n      notice_period: formData.notice_period,\n      job_description: formData.job_description,\n      job_description_url: formData.job_description_url,\n      status: formData.status\n    });\n    this.populateSkillsToFormArrayAndUI(formData.skills);\n    this.setJobDescriptionInEditor(formData.job_description);\n    this.updateExperienceSlidersUI(); // Update sliders based on patched form values\n  }\n\n  adjustExperienceValues(min, max) {\n    // If AI parsing results in 0-0, it often means \"any\" or \"not specified\", default to wide range.\n    if (min === 0 && max === 0) {\n      return [0, 30]; // Default full range\n    }\n\n    return [min, max];\n  }\n\n  mapJobTypeFromTitle(title) {\n    const lowerTitle = title.toLowerCase();\n    if (lowerTitle.includes('intern')) return 'Internship';\n    if (lowerTitle.includes('contract')) return 'Contract';\n    if (lowerTitle.includes('part-time')) return 'Part-time';\n    return 'Permanent'; // Default\n  }\n\n  parseExperienceRange(exp) {\n    const rangeMatch = exp.match(/(\\d+)\\s*-\\s*(\\d+)/);\n\n    if (rangeMatch) {\n      return [parseInt(rangeMatch[1], 10), parseInt(rangeMatch[2], 10)];\n    }\n\n    const singleMatch = exp.match(/(\\d+)\\s*years?/i);\n\n    if (singleMatch) {\n      const val = parseInt(singleMatch[1], 10);\n      return [val, val];\n    }\n\n    return [0, 0]; // Default or signal for adjustment\n  } // --- File Upload ---\n\n\n  onFileSelected(event) {\n    const input = event.target;\n\n    if (input.files && input.files.length > 0) {\n      const file = input.files[0];\n      const allowedExtensions = ['.pdf', '.docx', '.txt', '.xml', '.csv', '.doc'];\n      const ext = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));\n      const maxSize = 10 * 1024 * 1024; // 10MB\n\n      if (!allowedExtensions.includes(ext)) {\n        this.snackBar.open(`Invalid file format. Supported: ${allowedExtensions.join(', ')}`, 'Close', {\n          duration: 5000\n        });\n        this.clearFileInput(input);\n        return;\n      }\n\n      if (file.size > maxSize) {\n        this.snackBar.open('File size exceeds 10MB limit.', 'Close', {\n          duration: 5000\n        });\n        this.clearFileInput(input);\n        return;\n      }\n\n      this.selectedFile = file;\n    } else {\n      this.selectedFile = null;\n    }\n  }\n\n  clearFileInput(inputElement) {\n    this.selectedFile = null;\n\n    if (inputElement) {\n      inputElement.value = '';\n    }\n  }\n\n  uploadFile() {\n    if (!this.selectedFile) {\n      this.snackBar.open('Please select a file to upload.', 'Close', {\n        duration: 3000\n      });\n      return;\n    }\n\n    const token = this.corporateAuthService.getJWTToken();\n\n    if (!token) {\n      this.snackBar.open('Authentication required.', 'Close', {\n        duration: 5000\n      });\n      this.router.navigate(['/login-corporate']);\n      return;\n    }\n\n    this.isSubmitting = true; // Indicate loading for file upload too\n\n    this.jobDescriptionService.uploadFile(this.selectedFile, token).pipe(takeUntil(this.componentDestroyed$)).subscribe({\n      next: response => {\n        this.jobDataToLoad = response; // Store for processing\n\n        this.processAndPopulateForm(response);\n        this.snackBar.open('File uploaded and processed successfully.', 'Close', {\n          duration: 3000\n        });\n        this.clearFileInput(this.fileInput.nativeElement);\n        this.isSubmitting = false;\n      },\n      error: error => {\n        console.error('File upload error:', error);\n        this.snackBar.open(`File upload or processing failed: ${error.message || 'Unknown error'}`, 'Close', {\n          duration: 5000\n        });\n        this.clearFileInput(this.fileInput.nativeElement);\n        this.isSubmitting = false;\n      }\n    });\n  } // --- Location Search ---\n\n\n  setupLocationSearch() {\n    this.searchTerms.pipe(debounceTime(this.DEBOUNCE_DELAY), distinctUntilChanged(), switchMap(query => {\n      if (!query.trim()) {\n        this.isLoadingLocation = false;\n        this.showLocationSuggestions = false;\n        this.suggestions = [];\n        return []; // RxJS way to return empty and stop\n      }\n\n      this.isLoadingLocation = true;\n      return this.jobDescriptionService.fetchLocationSuggestions(query); // Assuming service method exists\n      // return this.fetchMockLocationSuggestions(query); // Or use mock\n    }), takeUntil(this.componentDestroyed$)).subscribe({\n      next: suggestions => {\n        this.suggestions = suggestions;\n        this.showLocationSuggestions = suggestions.length > 0;\n        this.isLoadingLocation = false;\n      },\n      error: error => {\n        this.snackBar.open('Failed to fetch location suggestions.', 'Close', {\n          duration: 5000\n        });\n        this.suggestions = [];\n        this.showLocationSuggestions = false;\n        this.isLoadingLocation = false;\n        console.error('Location suggestion error:', error);\n      }\n    });\n  }\n\n  onLocationInput(event) {\n    const query = event.target.value;\n    this.searchTerms.next(query);\n  }\n\n  selectLocationSuggestion(location) {\n    this.jobForm.patchValue({\n      location\n    });\n    this.showLocationSuggestions = false;\n    this.suggestions = [];\n\n    if (this.locationInput) {\n      this.locationInput.nativeElement.value = location; // Ensure input field UI updates\n    }\n  }\n\n  onLocationInputBlur() {\n    // Delay hiding to allow click on suggestion\n    setTimeout(() => {\n      if (this.suggestionsContainer && this.locationInput && !this.suggestionsContainer.nativeElement.contains(document.activeElement) && document.activeElement !== this.locationInput.nativeElement) {\n        this.showLocationSuggestions = false;\n      }\n    }, 150);\n  } // --- Skills Tag Input (DOM Heavy - Candidate for Child Component) ---\n\n\n  populateSkillsToFormArrayAndUI(skills) {\n    this.skillsFormArray.clear();\n    skills.forEach(skill => this.skillsFormArray.push(this.fb.control(skill)));\n    this.renderSkillTagsFromFormArray(); // New method to render UI from FormArray\n  }\n\n  renderSkillTagsFromFormArray() {\n    if (!this.tagContainerEl || !this.tagInputEl) return; // Clear existing tags (except the input itself)\n\n    Array.from(this.tagContainerEl.nativeElement.children).forEach(child => {\n      if (child !== this.tagInputEl.nativeElement && child.classList.contains('tag')) {\n        this.tagContainerEl.nativeElement.removeChild(child);\n      }\n    });\n    this.skillsFormArray.controls.forEach((control, index) => {\n      const skillText = control.value;\n      const tag = document.createElement('div');\n      tag.className = 'tag';\n      const tagTextSpan = document.createElement('span');\n      tagTextSpan.textContent = skillText;\n      tag.appendChild(tagTextSpan);\n      const removeBtn = document.createElement('button');\n      removeBtn.type = 'button'; // Prevent form submission\n\n      removeBtn.textContent = 'Ã—';\n      removeBtn.addEventListener('click', () => {\n        this.removeSkillAtIndex(index);\n      });\n      tag.appendChild(removeBtn);\n      this.tagContainerEl.nativeElement.insertBefore(tag, this.tagInputEl.nativeElement);\n    });\n  }\n\n  addSkillToFormArray(skillText) {\n    skillText = skillText.trim();\n\n    if (skillText && !this.skillsFormArray.value.includes(skillText)) {\n      this.skillsFormArray.push(this.fb.control(skillText));\n      this.renderSkillTagsFromFormArray(); // Re-render\n    }\n\n    if (this.tagInputEl) this.tagInputEl.nativeElement.value = '';\n    this.hideSkillSuggestions();\n  }\n\n  removeSkillAtIndex(index) {\n    this.skillsFormArray.removeAt(index);\n    this.renderSkillTagsFromFormArray(); // Re-render\n  }\n\n  removeLastSkill() {\n    if (this.skillsFormArray.length > 0) {\n      this.skillsFormArray.removeAt(this.skillsFormArray.length - 1);\n      this.renderSkillTagsFromFormArray();\n    }\n  }\n\n  initializeSkillsInput() {\n    if (!this.tagInputEl || !this.tagContainerEl || !this.skillsSuggestionsEl) {\n      console.warn('Skill input elements not found. Ensure ViewChild references are correct and elements exist.');\n      return;\n    }\n\n    const tagInput = this.tagInputEl.nativeElement;\n    const skillsSuggestionsDiv = this.skillsSuggestionsEl.nativeElement;\n    tagInput.addEventListener('input', () => {\n      const inputText = tagInput.value;\n\n      if (!inputText.trim()) {\n        this.hideSkillSuggestions();\n        return;\n      }\n\n      const filtered = this.availableSkills.filter(skill => skill.toLowerCase().includes(inputText.toLowerCase()) && !this.skillsFormArray.value.includes(skill));\n      this.showSkillSuggestions(filtered);\n    });\n    tagInput.addEventListener('keydown', e => {\n      switch (e.key) {\n        case 'Enter':\n          e.preventDefault();\n          const activeSuggestion = skillsSuggestionsDiv.querySelector('.active-suggestion');\n\n          if (activeSuggestion && activeSuggestion.textContent) {\n            this.addSkillToFormArray(activeSuggestion.textContent);\n          } else if (tagInput.value.trim()) {\n            this.addSkillToFormArray(tagInput.value.trim());\n          }\n\n          this.hideSkillSuggestions();\n          break;\n\n        case 'ArrowDown':\n          e.preventDefault();\n          this.navigateSkillSuggestions('down');\n          break;\n\n        case 'ArrowUp':\n          e.preventDefault();\n          this.navigateSkillSuggestions('up');\n          break;\n\n        case 'Backspace':\n          if (!tagInput.value && this.skillsFormArray.length > 0) {\n            this.removeLastSkill();\n          }\n\n          break;\n\n        case 'Escape':\n          this.hideSkillSuggestions();\n          break;\n      }\n    }); // Click outside to hide suggestions\n\n    document.addEventListener('click', e => {\n      if (this.tagContainerEl && skillsSuggestionsDiv && !this.tagContainerEl.nativeElement.contains(e.target) && !skillsSuggestionsDiv.contains(e.target)) {\n        this.hideSkillSuggestions();\n      }\n    });\n    this.tagContainerEl.nativeElement.addEventListener('click', e => {\n      if (e.target === this.tagContainerEl.nativeElement) {\n        tagInput.focus();\n      }\n    });\n    this.renderSkillTagsFromFormArray(); // Initial render if form has skills\n  }\n\n  showSkillSuggestions(suggestions) {\n    if (!this.skillsSuggestionsEl) return;\n    const skillsSuggestionsDiv = this.skillsSuggestionsEl.nativeElement;\n    skillsSuggestionsDiv.innerHTML = '';\n\n    if (suggestions.length === 0) {\n      skillsSuggestionsDiv.style.display = 'none';\n      return;\n    }\n\n    suggestions.forEach(suggestion => {\n      const item = document.createElement('div');\n      item.className = 'suggestion-item'; // Style this class\n\n      item.textContent = suggestion;\n      item.addEventListener('click', () => {\n        this.addSkillToFormArray(suggestion);\n        this.hideSkillSuggestions();\n        if (this.tagInputEl) this.tagInputEl.nativeElement.focus();\n      });\n      skillsSuggestionsDiv.appendChild(item);\n    });\n    skillsSuggestionsDiv.style.display = 'block';\n    this.activeSkillSuggestionIndex = -1;\n  }\n\n  hideSkillSuggestions() {\n    if (this.skillsSuggestionsEl) {\n      this.skillsSuggestionsEl.nativeElement.style.display = 'none';\n      this.skillsSuggestionsEl.nativeElement.innerHTML = '';\n    }\n\n    this.activeSkillSuggestionIndex = -1;\n  }\n\n  navigateSkillSuggestions(direction) {\n    var _a, _b, _c;\n\n    if (!this.skillsSuggestionsEl) return;\n    const items = this.skillsSuggestionsEl.nativeElement.querySelectorAll('.suggestion-item');\n    if (items.length === 0) return;\n    (_a = items[this.activeSkillSuggestionIndex]) === null || _a === void 0 ? void 0 : _a.classList.remove('active-suggestion');\n\n    if (direction === 'down') {\n      this.activeSkillSuggestionIndex = (this.activeSkillSuggestionIndex + 1) % items.length;\n    } else {\n      this.activeSkillSuggestionIndex = (this.activeSkillSuggestionIndex - 1 + items.length) % items.length;\n    }\n\n    (_b = items[this.activeSkillSuggestionIndex]) === null || _b === void 0 ? void 0 : _b.classList.add('active-suggestion');\n    (_c = items[this.activeSkillSuggestionIndex]) === null || _c === void 0 ? void 0 : _c.scrollIntoView({\n      block: 'nearest'\n    });\n  } // --- Rich Text Editor (DOM Heavy - Candidate for Child Component or Directive) ---\n\n\n  setJobDescriptionInEditor(description) {\n    const editor = document.getElementById('editor');\n\n    if (editor) {\n      editor.innerHTML = description;\n      this.checkEditorPlaceholder('editor');\n    }\n  }\n\n  updateJobDescriptionFromEditor(event) {\n    const editorContent = event.target.innerHTML;\n    this.jobForm.patchValue({\n      job_description: editorContent\n    });\n    this.checkEditorPlaceholder('editor');\n  }\n\n  checkEditorPlaceholder(editorId) {\n    const element = document.getElementById(editorId);\n    if (!element) return;\n    const isEmpty = element.innerHTML.trim() === '' || element.innerHTML.trim() === '<br>';\n    element.setAttribute('data-empty', isEmpty.toString()); // CSS :before pseudo-element can show placeholder based on [data-empty=\"true\"]\n  } // --- Experience Range Sliders (DOM Heavy - Candidate for Child Component) ---\n\n\n  updateExperienceSlidersUI() {\n    // Call this after form values are set (e.g., in populateForm or after reset)\n    this.setExperienceSliderUI('total', this.jobForm.value.total_experience_min, this.jobForm.value.total_experience_max);\n    this.setExperienceSliderUI('relevant', this.jobForm.value.relevant_experience_min, this.jobForm.value.relevant_experience_max);\n  }\n\n  setExperienceSliderUI(type, min, max) {\n    const prefix = type === 'total' ? 'total_' : 'relevant_';\n    const rangeIndicator = document.getElementById(`${prefix}rangeIndicator`);\n    const markerLeft = document.getElementById(`${prefix}markerLeft`);\n    const markerRight = document.getElementById(`${prefix}markerRight`);\n    const labelLeft = document.getElementById(`${prefix}labelLeft`);\n    const labelRight = document.getElementById(`${prefix}labelRight`);\n    const filledSegment = document.getElementById(`${prefix}filledSegment`);\n    if (!rangeIndicator || !markerLeft || !markerRight || !labelLeft || !labelRight || !filledSegment) return;\n    const trackWidth = rangeIndicator.offsetWidth;\n    const markerWidth = markerLeft.offsetWidth || 12; // Default if not rendered yet\n\n    const effectiveWidth = trackWidth - markerWidth; // Space for marker centers\n\n    const maxYears = 30;\n    const clampedMin = Math.max(0, Math.min(min, maxYears));\n    const clampedMax = Math.max(clampedMin, Math.min(max, maxYears));\n    const minPos = clampedMin / maxYears * effectiveWidth;\n    const maxPos = clampedMax / maxYears * effectiveWidth;\n    markerLeft.style.left = `${minPos}px`;\n    markerRight.style.left = `${maxPos}px`;\n    labelLeft.style.left = `${minPos + markerWidth / 2}px`;\n    labelLeft.textContent = `${clampedMin}yrs`;\n    labelRight.style.left = `${maxPos + markerWidth / 2}px`;\n    labelRight.textContent = `${clampedMax}yrs`;\n    filledSegment.style.left = `${minPos + markerWidth / 2}px`;\n    filledSegment.style.width = `${Math.max(0, maxPos - minPos)}px`;\n  }\n\n  initializeExperienceRangeSlider(type) {\n    const prefix = type === 'total' ? 'total_' : 'relevant_';\n    const rangeIndicator = document.getElementById(`${prefix}rangeIndicator`);\n    const markerLeft = document.getElementById(`${prefix}markerLeft`);\n    const markerRight = document.getElementById(`${prefix}markerRight`);\n    if (!rangeIndicator || !markerLeft || !markerRight) return;\n    let currentMarker = null;\n    const maxYears = 30;\n    const markerWidth = markerLeft.offsetWidth || 12;\n\n    const updateFormAndUIFromMarkers = () => {\n      if (!rangeIndicator || !markerLeft || !markerRight) return;\n      const trackWidth = rangeIndicator.offsetWidth;\n      if (trackWidth <= 0) return;\n      const effectiveWidth = trackWidth - markerWidth;\n      const leftPx = parseFloat(markerLeft.style.left || '0');\n      const rightPx = parseFloat(markerRight.style.left || '0');\n      let minYear = Math.round(leftPx / effectiveWidth * maxYears);\n      let maxYear = Math.round(rightPx / effectiveWidth * maxYears);\n      minYear = Math.max(0, Math.min(minYear, maxYears));\n      maxYear = Math.max(0, Math.min(maxYear, maxYears)); // Ensure min is not greater than max after rounding\n\n      if (minYear > maxYear) {\n        if (currentMarker === markerLeft) maxYear = minYear;else minYear = maxYear;\n      }\n\n      const formControlPrefix = type === 'total' ? 'total_experience' : 'relevant_experience';\n      this.jobForm.patchValue({\n        [`${formControlPrefix}_min`]: minYear,\n        [`${formControlPrefix}_max`]: maxYear\n      }, {\n        emitEvent: false\n      }); // Avoid re-triggering valueChanges if any\n\n      this.setExperienceSliderUI(type, minYear, maxYear); // Update labels and filled segment\n    };\n\n    const onMouseMove = e => {\n      if (!currentMarker || !rangeIndicator) return;\n      e.preventDefault();\n      const rect = rangeIndicator.getBoundingClientRect();\n      let newLeftPx = e.clientX - rect.left - markerWidth / 2; // Center of marker\n\n      const minBoundaryPx = 0;\n      const maxBoundaryPx = rangeIndicator.offsetWidth - markerWidth;\n\n      if (currentMarker === markerLeft) {\n        const rightMarkerPosPx = parseFloat(markerRight.style.left) || maxBoundaryPx;\n        newLeftPx = Math.max(minBoundaryPx, Math.min(newLeftPx, rightMarkerPosPx - markerWidth)); // Prevent overlap\n      } else {\n        // currentMarker === markerRight\n        const leftMarkerPosPx = parseFloat(markerLeft.style.left) || minBoundaryPx;\n        newLeftPx = Math.min(maxBoundaryPx, Math.max(newLeftPx, leftMarkerPosPx + markerWidth)); // Prevent overlap\n      }\n\n      newLeftPx = Math.max(minBoundaryPx, Math.min(newLeftPx, maxBoundaryPx)); // Clamp within bounds\n\n      currentMarker.style.left = `${newLeftPx}px`;\n      updateFormAndUIFromMarkers();\n    };\n\n    const onMouseUp = () => {\n      if (currentMarker) {\n        updateFormAndUIFromMarkers(); // Final precise update\n      }\n\n      currentMarker = null;\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n\n    const onMouseDown = (e, marker) => {\n      e.preventDefault();\n      currentMarker = marker;\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n    };\n\n    markerLeft.addEventListener('mousedown', e => onMouseDown(e, markerLeft));\n    markerRight.addEventListener('mousedown', e => onMouseDown(e, markerRight)); // Initial UI setup based on form values\n\n    const formControlPrefix = type === 'total' ? 'total_experience' : 'relevant_experience';\n    this.setExperienceSliderUI(type, this.jobForm.value[`${formControlPrefix}_min`], this.jobForm.value[`${formControlPrefix}_max`]);\n  } // --- Form Submission and Actions ---\n\n\n  onSubmit() {\n    if (this.currentStep === 'jobPost') {\n      if (this.jobForm.invalid) {\n        this.snackBar.open('Please fill all required fields correctly.', 'Close', {\n          duration: 5000\n        });\n        this.jobForm.markAllAsTouched(); // Mark fields to show errors\n        // Log errors for debugging\n\n        console.error('Form is invalid. Errors:', this.jobForm.errors);\n        Object.keys(this.jobForm.controls).forEach(key => {\n          var _a;\n\n          const controlErrors = (_a = this.jobForm.get(key)) === null || _a === void 0 ? void 0 : _a.errors;\n\n          if (controlErrors) {\n            console.error(`Control ${key} errors:`, controlErrors);\n          }\n        });\n        return;\n      }\n\n      const token = this.corporateAuthService.getJWTToken();\n\n      if (!token) {\n        this.snackBar.open('Authentication required. Please log in.', 'Close', {\n          duration: 5000\n        });\n        this.router.navigate(['/login-corporate']);\n        return;\n      }\n\n      this.isSubmitting = true;\n      const formValues = this.jobForm.getRawValue(); // Use getRawValue for disabled fields if any\n\n      const skillsFromForm = formValues.skills || [];\n      const primarySkillsCount = Math.ceil(skillsFromForm.length / 2);\n      const jobDetailsPayload = {\n        // Map all fields from formValues to JobDetailsModel structure\n        unique_id: formValues.unique_id || undefined,\n        role: formValues.role,\n        location: formValues.location,\n        job_type: formValues.job_type,\n        workplace_type: formValues.workplace_type,\n        total_experience_min: formValues.total_experience_min,\n        total_experience_max: formValues.total_experience_max,\n        relevant_experience_min: formValues.relevant_experience_min,\n        relevant_experience_max: formValues.relevant_experience_max,\n        budget_type: formValues.budget_type,\n        min_budget: formValues.min_budget,\n        max_budget: formValues.max_budget,\n        notice_period: formValues.notice_period,\n        skills: {\n          primary: skillsFromForm.slice(0, primarySkillsCount).map(skill => ({\n            skill,\n            skill_confidence: 0.9,\n            type_confidence: 0.9\n          })),\n          secondary: skillsFromForm.slice(primarySkillsCount).map(skill => ({\n            skill,\n            skill_confidence: 0.8,\n            type_confidence: 0.8\n          }))\n        },\n        job_description: formValues.job_description,\n        // job_description_url: formValues.job_description_url, // If model supports\n        status: formValues.status // Add any other fields required by JobDetailsModel that are in the form\n\n      }; // If job_description_url is part of your JobDetailsModel and you want to send it\n\n      if (formValues.job_description_url) {\n        jobDetailsPayload.job_description_url = formValues.job_description_url;\n      }\n\n      this.jobDescriptionService.saveJobPost(jobDetailsPayload, token).pipe(takeUntil(this.componentDestroyed$)).subscribe({\n        next: response => {\n          const message = response.message || (jobDetailsPayload.unique_id ? 'Job post updated successfully.' : 'Job post created successfully.');\n          this.snackBar.open(`${message} Proceeding to assessment setup.`, 'Close', {\n            duration: 3000\n          });\n\n          if (response.unique_id && !this.jobForm.value.unique_id) {\n            this.jobForm.patchValue({\n              unique_id: response.unique_id\n            });\n          }\n\n          this.currentStep = 'assessment';\n          this.isSubmitting = false;\n        },\n        error: error => {\n          this.snackBar.open(`Failed to save job post: ${error.message || 'Unknown error'}`, 'Close', {\n            duration: 5000\n          });\n          console.error('Job post save error:', error);\n          this.isSubmitting = false;\n        }\n      });\n    } else if (this.currentStep === 'assessment') {\n      // Logic for submitting assessment details (if any actual submission is needed)\n      // For now, it just navigates away\n      this.snackBar.open('Assessment step completed. Job post is live!', 'Close', {\n        duration: 3000\n      }); // this.resetFormAndState(); // Reset before navigating if it's a final step\n\n      this.router.navigate(['/job-posted']); // Or dashboard, or job list\n      // If navigating away, reset might not be strictly needed here unless user can come back to this instance\n    }\n  }\n\n  onCancel() {\n    if (this.currentStep === 'assessment') {\n      this.snackBar.open('Returning to job post editing.', 'Close', {\n        duration: 2000\n      });\n      this.currentStep = 'jobPost';\n    } else {\n      // currentStep === 'jobPost'\n      this.snackBar.open('Job post creation/editing cancelled.', 'Close', {\n        duration: 3000\n      }); // this.resetFormAndState(); // Optional: reset form or just navigate\n\n      this.router.navigate(['/dashboard']); // Or appropriate previous page\n    }\n  }\n\n  resetFormAndState() {\n    this.jobForm.reset({\n      unique_id: null,\n      role: '',\n      location: '',\n      job_type: '',\n      workplace_type: '',\n      total_experience_min: 0,\n      total_experience_max: 30,\n      relevant_experience_min: 0,\n      relevant_experience_max: 30,\n      budget_type: '',\n      min_budget: null,\n      max_budget: null,\n      notice_period: '',\n      // skills: [], // FormArray handled by clear()\n      job_description: '',\n      job_description_url: '',\n      status: 'draft'\n    });\n    this.skillsFormArray.clear(); // Clear FormArray\n\n    this.renderSkillTagsFromFormArray(); // Update UI for skills\n\n    if (this.fileInput) {\n      this.clearFileInput(this.fileInput.nativeElement);\n    }\n\n    this.setJobDescriptionInEditor(''); // Clear editor\n\n    this.updateExperienceSlidersUI(); // Reset sliders\n\n    this.currentStep = 'jobPost';\n    this.jobDataToLoad = null;\n    this.isSubmitting = false;\n    this.showLocationSuggestions = false;\n    this.suggestions = [];\n    if (this.locationInput) this.locationInput.nativeElement.value = ''; // Re-initialize any stateful UI components if needed, but typically reset should handle\n    // For skills, renderSkillTagsFromFormArray() already updates UI.\n    // For sliders, updateExperienceSlidersUI() does it.\n  }\n\n};\n\n__decorate([ViewChild('locationInput')], CreateJobPost1stPageComponent.prototype, \"locationInput\", void 0);\n\n__decorate([ViewChild('suggestionsContainer')], CreateJobPost1stPageComponent.prototype, \"suggestionsContainer\", void 0);\n\n__decorate([ViewChild('fileInput')], CreateJobPost1stPageComponent.prototype, \"fileInput\", void 0);\n\n__decorate([ViewChild('tagInput')], CreateJobPost1stPageComponent.prototype, \"tagInputEl\", void 0);\n\n__decorate([ViewChild('tagContainer')], CreateJobPost1stPageComponent.prototype, \"tagContainerEl\", void 0);\n\n__decorate([ViewChild('skillsSuggestions')], CreateJobPost1stPageComponent.prototype, \"skillsSuggestionsEl\", void 0);\n\nCreateJobPost1stPageComponent = __decorate([Component({\n  selector: 'app-create-job-post-1st-page',\n  templateUrl: './create-job-post-1st-page.component.html',\n  styleUrls: ['./create-job-post-1st-page.component.scss'] // Assuming SCSS as per new code, change to .css if needed\n\n})], CreateJobPost1stPageComponent);\nexport { CreateJobPost1stPageComponent };","map":null,"metadata":{},"sourceType":"module"}