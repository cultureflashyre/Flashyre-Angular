{"ast":null,"code":"import { throwError, BehaviorSubject, of } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport { Router } from '@angular/router';\nimport { tap, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@angular/router\";\nexport let CandidateService = /*#__PURE__*/(() => {\n  class CandidateService {\n    constructor(http, router) {\n      this.http = http;\n      this.router = router;\n      this.apiUrl = environment.apiUrl;\n      this.jobsApiUrl = environment.apiUrl + 'api/jobs/'; // Job-related properties\n\n      this.jobsSubject = new BehaviorSubject([]);\n      this.jobsCache = [];\n      this.isJobsFetched = false;\n      this.isFetching = false;\n      this.jobs$ = this.jobsSubject.asObservable();\n    } // ==================== AUTHENTICATION METHODS ====================\n\n\n    login(email, password) {\n      return this.http.post(`${this.apiUrl}login-candidate/`, {\n        email,\n        password\n      }).pipe(tap(response => {\n        if (response.token) {\n          localStorage.setItem('jwtToken', response.token); // Store token\n        }\n      }));\n    }\n\n    logout() {\n      localStorage.removeItem('jwtToken');\n      localStorage.removeItem('refreshToken');\n      localStorage.removeItem('userProfile');\n      this.router.navigate(['/login-candidate']);\n    }\n\n    getJWTToken() {\n      return localStorage.getItem('jwtToken');\n    }\n\n    getRefreshToken() {\n      return localStorage.getItem('refreshToken');\n    }\n\n    saveTokens(access, refresh) {\n      localStorage.setItem('jwtToken', access);\n      localStorage.setItem('refreshToken', refresh);\n    }\n\n    refreshToken() {\n      const refresh = this.getRefreshToken();\n\n      if (!refresh) {\n        return throwError(() => new Error('No refresh token available'));\n      }\n\n      return this.http.post(`${this.apiUrl}api/token/refresh/`, {\n        refresh\n      });\n    }\n\n    isLoggedIn() {\n      const token = this.getJWTToken();\n      return !!token;\n    } // ==================== JOB APPLICATION METHODS ====================\n\n\n    applyForJob(jobId) {\n      return this.http.post(`${this.apiUrl}api/apply/`, {\n        job_id: jobId\n      });\n    }\n\n    getAppliedJobs() {\n      return this.http.get(`${this.apiUrl}api/applied-jobs/`);\n    } // ==================== JOB MANAGEMENT METHODS ====================\n\n    /**\r\n     * Fetch jobs from API only once and cache them\r\n     */\n\n\n    fetchJobs() {\n      // If jobs are already cached, return them immediately\n      if (this.isJobsFetched && this.jobsCache.length > 0) {\n        this.jobsSubject.next(this.jobsCache);\n        return of(this.jobsCache);\n      } // If already fetching, don't make another request\n\n\n      if (this.isFetching) {\n        return this.jobs$;\n      }\n\n      this.isFetching = true;\n      return this.http.get(this.jobsApiUrl).pipe(tap(jobs => {\n        this.jobsCache = jobs;\n        this.isJobsFetched = true;\n        this.isFetching = false;\n        this.jobsSubject.next(jobs);\n      }), catchError(error => {\n        this.isFetching = false;\n        console.error('Error fetching jobs:', error);\n        throw error;\n      }));\n    }\n    /**\r\n     * Get jobs from cache (BehaviorSubject)\r\n     */\n\n\n    getJobs() {\n      return this.jobs$;\n    }\n    /**\r\n     * Get cached jobs synchronously\r\n     */\n\n\n    getCachedJobs() {\n      return this.jobsCache;\n    }\n    /**\r\n     * Check if jobs are already fetched and cached\r\n     */\n\n\n    areJobsCached() {\n      return this.isJobsFetched && this.jobsCache.length > 0;\n    }\n    /**\r\n     * Clear cache (useful for refresh scenarios)\r\n     */\n\n\n    clearCache_refresh() {\n      this.jobsCache = [];\n      this.isJobsFetched = false;\n      this.jobsSubject.next([]);\n    }\n    /**\r\n     * Update a specific job in cache (useful for status updates)\r\n     */\n\n\n    updateJobInCache(jobId, updates) {\n      const jobIndex = this.jobsCache.findIndex(job => job.job_id === jobId);\n\n      if (jobIndex !== -1) {\n        this.jobsCache[jobIndex] = Object.assign(Object.assign({}, this.jobsCache[jobIndex]), updates);\n        this.jobsSubject.next(this.jobsCache);\n      }\n    }\n    /**\r\n     * Remove job from cache\r\n     */\n\n\n    removeJobFromCache(jobId) {\n      this.jobsCache = this.jobsCache.filter(job => job.job_id !== jobId);\n      this.jobsSubject.next(this.jobsCache);\n    }\n\n  }\n\n  CandidateService.ɵfac = function CandidateService_Factory(t) {\n    return new (t || CandidateService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.Router));\n  };\n\n  CandidateService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CandidateService,\n    factory: CandidateService.ɵfac,\n    providedIn: 'root'\n  }); // Export the same service as AuthService for backward compatibility\n\n  return CandidateService;\n})();\nexport { CandidateService as AuthService }; // Export the same service as JobService for backward compatibility  \n\nexport { CandidateService as JobService };","map":null,"metadata":{},"sourceType":"module"}