{"ast":null,"code":"// src/app/pages/create-job-post-1st-page/create-job-post-1st-page.component.ts\nimport { __decorate, __param } from \"tslib\";\nimport { Component, ViewChild, Inject } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { Validators } from '@angular/forms';\nimport { of, fromEvent, Subscription } from 'rxjs'; // Added Subscription\n\nimport { debounceTime, distinctUntilChanged, switchMap, catchError, map, tap } from 'rxjs/operators';\nlet CreateJobPost1stPageComponent = class CreateJobPost1stPageComponent {\n  constructor(title, meta, fb, snackBar, jobDescriptionService, corporateAuthService, router, route, ngZone, renderer, document, skillService) {\n    this.title = title;\n    this.meta = meta;\n    this.fb = fb;\n    this.snackBar = snackBar;\n    this.jobDescriptionService = jobDescriptionService;\n    this.corporateAuthService = corporateAuthService;\n    this.router = router;\n    this.route = route;\n    this.ngZone = ngZone;\n    this.renderer = renderer;\n    this.document = document;\n    this.skillService = skillService; // It's highly recommended to move API keys to environment variables or a configuration service\n    // and not hardcode them in components, especially if the code is committed to a public repository.\n\n    this.googleMapsApiKey = 'AIzaSyCYvHT8TXJdvdfr0CBRV62q5MzaD008hAE'; // Replace with your actual key\n\n    this.googleScriptLoaded = false;\n    this.suggestions = [];\n    this.isLoading = false;\n    this.showSuggestions = false;\n    this.selectedFile = null;\n    this.DEBOUNCE_DELAY = 300;\n    this.SKILL_DEBOUNCE_DELAY = 400;\n    this.currentStep = 'jobPost';\n    this.isSubmitting = false;\n    this.isFileUploadCompletedSuccessfully = false;\n    this.displayedFileName = null;\n    this.jobData = null;\n    this.isViewInitialized = false;\n    this.isLoadingSkills = false;\n    this.subscriptions = new Subscription(); // To manage subscriptions\n\n    this.jobForm = this.fb.group({\n      role: ['', [Validators.required, Validators.maxLength(100)]],\n      location: ['', [Validators.required, Validators.maxLength(200)]],\n      job_type: ['', [Validators.required]],\n      workplace_type: ['', [Validators.required]],\n      total_experience_min: [0, [Validators.required, Validators.min(0), Validators.max(30)]],\n      total_experience_max: [30, [Validators.required, Validators.min(0), Validators.max(30)]],\n      relevant_experience_min: [0, [Validators.required, Validators.min(0), Validators.max(30)]],\n      relevant_experience_max: [30, [Validators.required, Validators.min(0), Validators.max(30)]],\n      budget_type: ['', [Validators.required]],\n      min_budget: [null, [Validators.required, Validators.min(0)]],\n      max_budget: [null, [Validators.required, Validators.min(0)]],\n      notice_period: ['', [Validators.required, Validators.maxLength(50)]],\n      skills: [[], [Validators.required]],\n      job_description: ['', [Validators.maxLength(5000), Validators.required]],\n      job_description_url: ['', [Validators.maxLength(200)]],\n      unique_id: ['']\n    }, {\n      validators: this.experienceRangeValidator\n    });\n  }\n\n  ngOnInit() {\n    this.title.setTitle('Create Job Post - Flashyre');\n    this.meta.addTags([{\n      property: 'og:title',\n      content: 'Create Job Post - Flashyre'\n    }, {\n      property: 'og:image',\n      content: 'https://aheioqhobo.cloudimg.io/v7/_playground-bucket-v2.teleporthq.io_/8203932d-6f2d-4493-a7b2-7000ee521aa2/9aea8e9c-27ce-4011-a345-94a92ae2dbf8?org_if_sml=1&force_format=original'\n    }]);\n    this.loadGoogleMapsScript().catch(error => {\n      console.error('Google Maps script could not be loaded (initiated from ngOnInit).', error);\n    });\n\n    if (!this.corporateAuthService.isLoggedIn()) {\n      this.snackBar.open('Please log in to create a job post.', 'Close', {\n        duration: 5000\n      });\n      this.router.navigate(['/login-corporate']);\n      return;\n    }\n\n    const uniqueId = this.route.snapshot.paramMap.get('unique_id');\n\n    if (uniqueId) {\n      console.log('Editing existing job post with unique_id:', uniqueId); // TODO: Fetch job data if editing an existing post\n      // this.jobDescriptionService.getJobPost(uniqueId, this.corporateAuthService.getJWTToken()!).subscribe(data => {\n      //   this.jobData = data;\n      //   if (this.isViewInitialized) this.populateForm(data);\n      // });\n    }\n  }\n\n  loadGoogleMapsScript() {\n    return new Promise((resolve, reject) => {\n      if (this.googleScriptLoaded && typeof google !== 'undefined' && google.maps && google.maps.places) {\n        resolve();\n        return;\n      }\n\n      if (this.document.querySelector(`script[src*=\"maps.googleapis.com/maps/api/js\"]`)) {\n        let attempts = 0;\n        const intervalId = setInterval(() => {\n          attempts++;\n\n          if (typeof google !== 'undefined' && google.maps && google.maps.places) {\n            clearInterval(intervalId);\n            this.googleScriptLoaded = true;\n            resolve();\n          } else if (attempts > 30) {\n            // Timeout after ~3 seconds\n            clearInterval(intervalId);\n            console.warn('Google Maps script tag found, but API not available after timeout.');\n            this.googleScriptLoaded = false;\n            reject(new Error('Google Maps script loaded but API not available.'));\n          }\n        }, 100);\n        return;\n      }\n\n      const script = this.renderer.createElement('script');\n      script.type = 'text/javascript'; // Add async and defer for best practices, though Google's warning might still appear for dynamic loads.\n\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.googleMapsApiKey}&libraries=places&loading=async`;\n      script.async = true;\n      script.defer = true;\n\n      script.onload = () => {\n        this.googleScriptLoaded = true;\n        resolve();\n      };\n\n      script.onerror = error => {\n        console.error('Error loading Google Maps script:', error);\n        this.googleScriptLoaded = false;\n        reject(error);\n      };\n\n      this.renderer.appendChild(this.document.head, script);\n    });\n  }\n\n  ngAfterViewInit() {\n    this.isViewInitialized = true; // Initialize UI elements that don't depend on external scripts first\n\n    this.initializeSkillsInput();\n    this.initializeRange('total');\n    this.initializeRange('relevant');\n    this.checkEmpty('editor'); // Initial check for placeholder\n\n    if (this.jobData) {\n      this.populateForm(this.jobData); // Populates form and calls UI updates\n    } else {\n      this.updateExperienceUI(); // Ensure sliders are set to default if no pre-existing data\n    }\n\n    if (this.currentStep === 'jobPost') {\n      this.initLocationServices();\n    }\n  }\n\n  initLocationServices() {\n    if (this.googleScriptLoaded && typeof google !== 'undefined' && google.maps && google.maps.places) {\n      this.attemptGooglePlacesInitialization();\n    } else {\n      this.loadGoogleMapsScript().then(() => {\n        this.attemptGooglePlacesInitialization();\n      }).catch(error => {\n        console.error('Google Maps script could not be loaded during initLocationServices.', error);\n\n        if (this.currentStep === 'jobPost') {\n          // Only show snackbar if relevant\n          this.snackBar.open('Could not load location services. Please try again later.', 'Close', {\n            duration: 5000\n          });\n        }\n      });\n    }\n  }\n\n  attemptGooglePlacesInitialization() {\n    setTimeout(() => {\n      this.ngZone.run(() => {\n        if (this.currentStep === 'jobPost' && this.locationInput && this.locationInput.nativeElement) {\n          this.initializeGooglePlacesAutocomplete();\n          this.setupLocationInputListener();\n        } else if (this.currentStep === 'jobPost') {\n          console.warn('Google Places Autocomplete setup skipped: locationInput not ready or not in jobPost step.');\n        }\n      });\n    }, 150); // Slightly increased delay for safety\n  }\n\n  initializeGooglePlacesAutocomplete() {\n    if (typeof google === 'undefined' || !google.maps || !google.maps.places) {\n      console.warn('Google Maps or Places library not loaded. Autocomplete cannot be initialized.');\n      return;\n    }\n\n    if (!this.locationInput || !this.locationInput.nativeElement || !(this.locationInput.nativeElement instanceof HTMLInputElement)) {\n      console.warn('Location input HTML element not found or not an input. Autocomplete cannot be initialized.');\n      return;\n    }\n\n    if (this.autocomplete) {\n      return;\n    } // Consider Google's recommendation to move to PlaceAutocompleteElement in the future\n    // console.warn(\"Using deprecated google.maps.places.Autocomplete. Consider migrating to PlaceAutocompleteElement.\");\n\n\n    this.autocomplete = new google.maps.places.Autocomplete(this.locationInput.nativeElement, {\n      types: ['(cities)']\n    });\n    this.autocomplete.addListener('place_changed', () => {\n      this.ngZone.run(() => {\n        var _a, _b;\n\n        const place = this.autocomplete.getPlace();\n\n        if (place && place.formatted_address) {\n          this.jobForm.patchValue({\n            location: place.formatted_address\n          });\n          (_a = this.jobForm.get('location')) === null || _a === void 0 ? void 0 : _a.markAsDirty();\n        } else if (place && place.name) {\n          this.jobForm.patchValue({\n            location: place.name\n          });\n          (_b = this.jobForm.get('location')) === null || _b === void 0 ? void 0 : _b.markAsDirty();\n        }\n\n        this.suggestions = [];\n        this.showSuggestions = false;\n      });\n    });\n  }\n\n  setupLocationInputListener() {\n    if (!this.locationInput || !this.locationInput.nativeElement) {\n      console.warn('Location input not available for setting up listener.');\n      return;\n    }\n\n    const locationInputSub = fromEvent(this.locationInput.nativeElement, 'input').pipe(map(event => event.target.value), debounceTime(this.DEBOUNCE_DELAY), distinctUntilChanged(), tap(query => this.isLoading = !!query.trim()), switchMap(query => {\n      const trimmedQuery = query.trim();\n      const pacContainer = this.document.querySelector('.pac-container');\n      const isPacContainerVisible = pacContainer ? getComputedStyle(pacContainer).display !== 'none' : false;\n\n      if (!trimmedQuery || this.autocomplete && isPacContainerVisible) {\n        this.isLoading = false;\n        return of([]);\n      }\n\n      this.isLoading = false;\n      return of([]);\n    })).subscribe({\n      next: () => {},\n      error: err => {\n        this.isLoading = false;\n        console.error(\"Error in location input listener stream:\", err);\n      }\n    });\n    this.subscriptions.add(locationInputSub); // Add to subscriptions for cleanup\n  }\n\n  onInput(event) {}\n\n  selectSuggestion(location) {\n    var _a;\n\n    this.jobForm.patchValue({\n      location\n    });\n    (_a = this.jobForm.get('location')) === null || _a === void 0 ? void 0 : _a.markAsDirty();\n    this.showSuggestions = false;\n    this.suggestions = [];\n  }\n\n  adjustExperienceRange(min, max) {\n    return min === 0 && max === 0 ? [0, 30] : [min, max];\n  }\n\n  experienceRangeValidator(form) {\n    var _a, _b, _c, _d, _e, _f;\n\n    const totalMin = (_a = form.get('total_experience_min')) === null || _a === void 0 ? void 0 : _a.value;\n    const totalMax = (_b = form.get('total_experience_max')) === null || _b === void 0 ? void 0 : _b.value;\n    const relevantMin = (_c = form.get('relevant_experience_min')) === null || _c === void 0 ? void 0 : _c.value;\n    const relevantMax = (_d = form.get('relevant_experience_max')) === null || _d === void 0 ? void 0 : _d.value;\n    const minBudget = (_e = form.get('min_budget')) === null || _e === void 0 ? void 0 : _e.value;\n    const maxBudget = (_f = form.get('max_budget')) === null || _f === void 0 ? void 0 : _f.value;\n    let errors = {};\n    if (totalMin !== null && totalMax !== null && totalMin > totalMax) errors['invalidTotalExperience'] = true;\n    if (relevantMin !== null && relevantMax !== null && relevantMin > relevantMax) errors['invalidRelevantExperience'] = true;\n    if (minBudget !== null && maxBudget !== null && minBudget > maxBudget) errors['invalidBudgetRange'] = true;\n    return Object.keys(errors).length ? errors : null;\n  }\n\n  triggerFileInput() {\n    if (this.fileInput) this.fileInput.nativeElement.click();\n  }\n\n  onFileSelected(event) {\n    this.isFileUploadCompletedSuccessfully = false;\n    const input = event.target;\n\n    if (input.files && input.files.length > 0) {\n      const file = input.files[0];\n      const allowedExtensions = ['.pdf', '.docx', '.txt', '.xml', '.csv', '.doc'];\n      const ext = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));\n      const maxSize = 10 * 1024 * 1024;\n\n      if (!allowedExtensions.includes(ext)) {\n        this.snackBar.open(`Invalid file format. Supported: ${allowedExtensions.join(', ')}`, 'Close', {\n          duration: 5000\n        });\n        this.clearFileInput(input);\n        return;\n      }\n\n      if (file.size > maxSize) {\n        this.snackBar.open('File size exceeds 10MB limit.', 'Close', {\n          duration: 5000\n        });\n        this.clearFileInput(input);\n        return;\n      }\n\n      this.selectedFile = file;\n      this.displayedFileName = file.name;\n\n      this._performUpload(this.selectedFile);\n    } else {\n      this.selectedFile = null;\n    }\n  }\n\n  clearFileInput(inputElement) {\n    this.selectedFile = null;\n    this.displayedFileName = null;\n\n    if (inputElement) {\n      inputElement.value = '';\n    } else if (this.fileInput && this.fileInput.nativeElement) {\n      this.fileInput.nativeElement.value = '';\n    }\n  }\n\n  _performUpload(file) {\n    if (!file) return;\n    const token = this.corporateAuthService.getJWTToken();\n\n    if (!token) {\n      this.snackBar.open('Authentication required. Please log in.', 'Close', {\n        duration: 5000\n      });\n      this.router.navigate(['/login-corporate']);\n      return;\n    }\n\n    this.isSubmitting = true;\n    this.isFileUploadCompletedSuccessfully = false;\n    const uploadSub = this.jobDescriptionService.uploadFile(file, token).subscribe({\n      next: response => {\n        this.jobData = response;\n        this.populateForm(response);\n        this.snackBar.open('File uploaded and processed successfully.', 'Close', {\n          duration: 3000\n        });\n        this.isSubmitting = false;\n        this.isFileUploadCompletedSuccessfully = true;\n      },\n      error: error => {\n        console.error('File upload error:', error);\n        this.snackBar.open(`File upload or processing failed: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`, 'Close', {\n          duration: 5000\n        });\n        this.isSubmitting = false;\n        this.isFileUploadCompletedSuccessfully = false;\n      }\n    });\n    this.subscriptions.add(uploadSub);\n  }\n\n  updateExperienceUI() {\n    this.setExperienceRange('total', this.jobForm.value.total_experience_min, this.jobForm.value.total_experience_max);\n    this.setExperienceRange('relevant', this.jobForm.value.relevant_experience_min, this.jobForm.value.relevant_experience_max);\n  }\n\n  populateForm(jobData) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    let role, location, job_type, workplace_type;\n    let total_experience_min, total_experience_max;\n    let relevant_experience_min, relevant_experience_max;\n    let budget_type, min_budget, max_budget;\n    let notice_period, skills, job_description;\n    let unique_id_val = '',\n        job_description_url_val = '';\n\n    if ('job_details' in jobData) {\n      const aiJobData = jobData;\n      const details = aiJobData.job_details;\n      const [minExp, maxExp] = this.parseExperience(((_a = details.experience) === null || _a === void 0 ? void 0 : _a.value) || '0-0 years');\n      role = details.job_titles && details.job_titles.length > 0 ? (_b = details.job_titles[0]) === null || _b === void 0 ? void 0 : _b.value : '';\n      location = details.location || '';\n      job_type = this.mapJobType(details.job_titles && details.job_titles.length > 0 ? (_c = details.job_titles[0]) === null || _c === void 0 ? void 0 : _c.value : '');\n      workplace_type = details.workplace_type || 'Remote';\n      [total_experience_min, total_experience_max] = this.adjustExperienceRange(minExp, maxExp);\n      [relevant_experience_min, relevant_experience_max] = this.adjustExperienceRange(minExp, maxExp);\n      budget_type = details.budget_type || 'Annually';\n      min_budget = details.min_budget || null;\n      max_budget = details.max_budget || null;\n      notice_period = details.notice_period || '30 days';\n      skills = [...(((_d = details.skills) === null || _d === void 0 ? void 0 : _d.primary) || []).map(s => s.skill), ...(((_e = details.skills) === null || _e === void 0 ? void 0 : _e.secondary) || []).map(s => s.skill)];\n      job_description = details.job_description || '';\n      unique_id_val = aiJobData.unique_id || ((_f = this.jobForm.get('unique_id')) === null || _f === void 0 ? void 0 : _f.value) || '';\n      job_description_url_val = aiJobData.file_url || '';\n    } else {\n      const details = jobData;\n      role = details.role;\n      location = details.location;\n      job_type = details.job_type;\n      workplace_type = details.workplace_type;\n      [total_experience_min, total_experience_max] = this.adjustExperienceRange(details.total_experience_min, details.total_experience_max);\n      [relevant_experience_min, relevant_experience_max] = this.adjustExperienceRange(details.relevant_experience_min, details.relevant_experience_max);\n      budget_type = details.budget_type;\n      min_budget = details.min_budget;\n      max_budget = details.max_budget;\n      notice_period = details.notice_period;\n      let primarySkills = Array.isArray((_g = details.skills) === null || _g === void 0 ? void 0 : _g.primary) ? details.skills.primary.map(s => s.skill) : [];\n      let secondarySkills = Array.isArray((_h = details.skills) === null || _h === void 0 ? void 0 : _h.secondary) ? details.skills.secondary.map(s => s.skill) : [];\n      skills = [...primarySkills, ...secondarySkills];\n      job_description = details.job_description;\n      unique_id_val = details.unique_id || ((_j = this.jobForm.get('unique_id')) === null || _j === void 0 ? void 0 : _j.value) || '';\n      job_description_url_val = details.job_description_url || '';\n    }\n\n    this.jobForm.patchValue({\n      role,\n      location,\n      job_type,\n      workplace_type,\n      total_experience_min,\n      total_experience_max,\n      relevant_experience_min,\n      relevant_experience_max,\n      budget_type,\n      min_budget,\n      max_budget,\n      notice_period,\n      skills,\n      job_description,\n      job_description_url: job_description_url_val,\n      unique_id: unique_id_val\n    });\n\n    if (this.isViewInitialized) {\n      this.populateSkills(skills); // UI for skills\n\n      this.setJobDescription(job_description); // UI for editor (sets innerHTML)\n\n      this.updateExperienceUI(); // UI for sliders\n    }\n  }\n\n  populateSkills(skills) {\n    const tagContainer = this.document.getElementById('tagContainer');\n    const tagInput = this.document.getElementById('tagInput');\n\n    if (!tagContainer || !tagInput) {\n      if (this.isViewInitialized) console.warn('Skill container or input not found during populateSkills.');\n      return;\n    }\n\n    const existingTags = tagContainer.querySelectorAll('.tag');\n    existingTags.forEach(tag => tag.remove());\n    skills.forEach(skillText => {\n      if (!skillText.trim()) return;\n      const tag = this.renderer.createElement('div');\n      this.renderer.addClass(tag, 'tag');\n      const tagTextSpan = this.renderer.createElement('span');\n      tagTextSpan.textContent = skillText;\n      this.renderer.appendChild(tag, tagTextSpan);\n      const removeBtn = this.renderer.createElement('button');\n      removeBtn.textContent = '×';\n      this.renderer.setAttribute(removeBtn, 'type', 'button');\n      this.renderer.listen(removeBtn, 'click', () => {\n        var _a, _b, _c;\n\n        this.renderer.removeChild(tagContainer, tag);\n        const currentSkills = ((_a = this.jobForm.get('skills')) === null || _a === void 0 ? void 0 : _a.value) || [];\n        this.jobForm.patchValue({\n          skills: currentSkills.filter(s => s !== skillText)\n        });\n        (_b = this.jobForm.get('skills')) === null || _b === void 0 ? void 0 : _b.markAsDirty();\n        (_c = this.jobForm.get('skills')) === null || _c === void 0 ? void 0 : _c.updateValueAndValidity();\n      });\n      this.renderer.appendChild(tag, removeBtn);\n      this.renderer.insertBefore(tagContainer, tag, tagInput);\n    });\n  }\n\n  setJobDescription(description) {\n    const editor = this.document.getElementById('editor');\n\n    if (editor) {\n      editor.innerHTML = description; // Set content for display\n\n      this.checkEmpty('editor'); // Update placeholder\n      // Form control is updated in populateForm or updateJobDescriptionFromEditor\n    } else if (this.isViewInitialized) {\n      console.warn('Job description editor element not found.');\n    }\n  }\n\n  updateJobDescriptionFromEditor(event) {\n    var _a;\n\n    const editorContent = event.target.innerHTML; // Only patch if different to avoid unnecessary change detection cycles\n\n    if (((_a = this.jobForm.get('job_description')) === null || _a === void 0 ? void 0 : _a.value) !== editorContent) {\n      this.jobForm.patchValue({\n        job_description: editorContent\n      });\n    }\n\n    this.checkEmpty('editor'); // Call public method\n  }\n\n  setExperienceRange(type, min, max) {\n    const prefix = type === 'total' ? 'total_' : 'relevant_';\n    const rangeIndicator = this.document.getElementById(`${prefix}rangeIndicator`);\n    const markerLeft = this.document.getElementById(`${prefix}markerLeft`);\n    const markerRight = this.document.getElementById(`${prefix}markerRight`);\n    const labelLeft = this.document.getElementById(`${prefix}labelLeft`);\n    const labelRight = this.document.getElementById(`${prefix}labelRight`);\n    const filledSegment = this.document.getElementById(`${prefix}filledSegment`);\n\n    if (!rangeIndicator || !markerLeft || !markerRight || !labelLeft || !labelRight || !filledSegment) {\n      if (this.isViewInitialized) console.warn(`Experience range UI elements not found for type: ${type}`);\n      return;\n    }\n\n    const rect = rangeIndicator.getBoundingClientRect();\n    const width = rect.width > 0 ? rect.width : rangeIndicator.offsetWidth;\n    const maxYears = 30;\n    const markerWidth = markerLeft.offsetWidth || 12;\n    const effectiveWidth = Math.max(1, width - markerWidth);\n    const clampedMin = Math.max(0, Math.min(min, maxYears));\n    const clampedMax = Math.max(clampedMin, Math.min(max, maxYears));\n    const minPos = clampedMin / maxYears * effectiveWidth;\n    const maxPos = clampedMax / maxYears * effectiveWidth;\n    markerLeft.style.left = `${minPos}px`;\n    markerRight.style.left = `${maxPos}px`;\n    labelLeft.style.left = `${minPos + markerWidth / 2}px`;\n    labelLeft.textContent = `${clampedMin}yrs`;\n    labelRight.style.left = `${maxPos + markerWidth / 2}px`;\n    labelRight.textContent = `${clampedMax}yrs`;\n    filledSegment.style.left = `${minPos + markerWidth / 2}px`;\n    filledSegment.style.width = `${Math.max(0, maxPos - minPos)}px`;\n  } // Changed to public to be callable from template\n\n\n  checkEmpty(id) {\n    var _a, _b, _c, _d, _e, _f;\n\n    const element = this.document.getElementById(id);\n    if (!element) return;\n    const isEmpty = !((_a = element.textContent) === null || _a === void 0 ? void 0 : _a.trim()) && !element.querySelector('img, li, table');\n    element.setAttribute('data-empty', isEmpty ? 'true' : 'false'); // If using for validation feedback on the job_description field\n\n    if (id === 'editor' && ((_b = this.jobForm.get('job_description')) === null || _b === void 0 ? void 0 : _b.touched)) {\n      if (isEmpty) {\n        (_c = this.jobForm.get('job_description')) === null || _c === void 0 ? void 0 : _c.setErrors({\n          'required': true\n        });\n      } else {\n        // Clear 'required' error if content exists, but preserve other potential errors\n        const currentErrors = (_d = this.jobForm.get('job_description')) === null || _d === void 0 ? void 0 : _d.errors;\n\n        if (currentErrors && currentErrors['required']) {\n          delete currentErrors['required'];\n\n          if (Object.keys(currentErrors).length === 0) {\n            (_e = this.jobForm.get('job_description')) === null || _e === void 0 ? void 0 : _e.setErrors(null);\n          } else {\n            (_f = this.jobForm.get('job_description')) === null || _f === void 0 ? void 0 : _f.setErrors(currentErrors);\n          }\n        }\n      }\n    }\n  }\n\n  mapJobType(title) {\n    if (!title) return 'Permanent';\n    const lowerTitle = title.toLowerCase();\n    if (lowerTitle.includes('intern')) return 'Internship';\n    if (lowerTitle.includes('contract')) return 'Contract';\n    if (lowerTitle.includes('part-time') || lowerTitle.includes('part time')) return 'Part-time';\n    return 'Permanent';\n  }\n\n  initializeRange(type) {\n    const prefix = type === 'total' ? 'total_' : 'relevant_';\n    const rangeIndicator = this.document.getElementById(`${prefix}rangeIndicator`);\n    const markerLeft = this.document.getElementById(`${prefix}markerLeft`);\n    const markerRight = this.document.getElementById(`${prefix}markerRight`);\n\n    if (!rangeIndicator || !markerLeft || !markerRight) {\n      if (this.isViewInitialized) console.warn(`Range indicator elements not found for type: ${type}`);\n      return;\n    }\n\n    let isDragging = false;\n    let currentMarker = null;\n    const maxYears = 30;\n    const markerWidth = markerLeft.offsetWidth || 12;\n\n    const updateUIFromMarkers = () => {\n      const rect = rangeIndicator.getBoundingClientRect();\n      if (rect.width <= 0) return;\n      const effectiveWidth = rect.width - markerWidth;\n      if (effectiveWidth <= 0) return;\n      let leftPosPx = parseFloat(markerLeft.style.left) || 0;\n      let rightPosPx = parseFloat(markerRight.style.left) || effectiveWidth;\n      leftPosPx = Math.max(0, Math.min(leftPosPx, effectiveWidth));\n      rightPosPx = Math.max(0, Math.min(rightPosPx, effectiveWidth));\n\n      if (leftPosPx > rightPosPx) {\n        if (currentMarker === markerLeft) leftPosPx = rightPosPx;else rightPosPx = leftPosPx;\n      }\n\n      const minYearRaw = Math.round(leftPosPx / effectiveWidth * maxYears);\n      const maxYearRaw = Math.round(rightPosPx / effectiveWidth * maxYears);\n      const minYear = Math.min(minYearRaw, maxYearRaw);\n      const maxYear = Math.max(minYearRaw, maxYearRaw);\n      this.jobForm.patchValue(type === 'total' ? {\n        total_experience_min: minYear,\n        total_experience_max: maxYear\n      } : {\n        relevant_experience_min: minYear,\n        relevant_experience_max: maxYear\n      }, {\n        emitEvent: false\n      });\n      this.setExperienceRange(type, this.jobForm.value[`${type}_experience_min`], this.jobForm.value[`${type}_experience_max`]);\n    };\n\n    const onMouseMove = e => {\n      if (!isDragging || !currentMarker) return;\n      e.preventDefault();\n      const rect = rangeIndicator.getBoundingClientRect();\n      let newLeftPx = e.clientX - rect.left - markerWidth / 2;\n      const minBoundaryPx = 0;\n      const maxBoundaryPx = rect.width - markerWidth;\n\n      if (currentMarker === markerLeft) {\n        const rightMarkerPos = parseFloat(markerRight.style.left) || maxBoundaryPx;\n        newLeftPx = Math.max(minBoundaryPx, Math.min(newLeftPx, rightMarkerPos));\n      } else {\n        const leftMarkerPos = parseFloat(markerLeft.style.left) || minBoundaryPx;\n        newLeftPx = Math.min(maxBoundaryPx, Math.max(newLeftPx, leftMarkerPos));\n      }\n\n      currentMarker.style.left = `${newLeftPx}px`;\n      updateUIFromMarkers();\n    };\n\n    const onMouseUp = () => {\n      var _a, _b;\n\n      if (isDragging) {\n        updateUIFromMarkers();\n        (_a = this.jobForm.get(type === 'total' ? 'total_experience_min' : 'relevant_experience_min')) === null || _a === void 0 ? void 0 : _a.markAsDirty();\n        (_b = this.jobForm.get(type === 'total' ? 'total_experience_max' : 'relevant_experience_max')) === null || _b === void 0 ? void 0 : _b.markAsDirty();\n        this.jobForm.updateValueAndValidity();\n      }\n\n      isDragging = false;\n      currentMarker = null;\n      this.document.removeEventListener('mousemove', onMouseMove);\n      this.document.removeEventListener('mouseup', onMouseUp);\n    };\n\n    const onMouseDown = (e, marker) => {\n      e.preventDefault();\n      isDragging = true;\n      currentMarker = marker;\n      this.document.addEventListener('mousemove', onMouseMove);\n      this.document.addEventListener('mouseup', onMouseUp);\n    };\n\n    markerLeft.addEventListener('mousedown', e => onMouseDown(e, markerLeft));\n    markerRight.addEventListener('mousedown', e => onMouseDown(e, markerRight));\n    this.setExperienceRange(type, this.jobForm.value[`${type}_experience_min`], this.jobForm.value[`${type}_experience_max`]);\n  }\n\n  parseExperience(exp) {\n    if (!exp) return [0, 0];\n    const rangeMatch = exp.match(/(\\d+)\\s*-\\s*(\\d+)/);\n    if (rangeMatch) return [parseInt(rangeMatch[1], 10), parseInt(rangeMatch[2], 10)];\n    const singleMatchMore = exp.match(/(\\d+)\\+\\s*years?/i) || exp.match(/more than\\s*(\\d+)\\s*years?/i);\n\n    if (singleMatchMore) {\n      const val = parseInt(singleMatchMore[1], 10);\n      return [val, 30];\n    }\n\n    const singleMatchLess = exp.match(/less than\\s*(\\d+)\\s*years?/i) || exp.match(/up to\\s*(\\d+)\\s*years?/i);\n\n    if (singleMatchLess) {\n      const val = parseInt(singleMatchLess[1], 10);\n      return [0, val];\n    }\n\n    const singleMatch = exp.match(/(\\d+)\\s*years?/i);\n\n    if (singleMatch) {\n      const val = parseInt(singleMatch[1], 10);\n      return [val, val];\n    }\n\n    return [0, 0];\n  }\n\n  handleOutsideClick(event) {\n    setTimeout(() => {\n      const relatedTarget = event.relatedTarget;\n      const pacContainer = this.document.querySelector('.pac-container');\n      if (this.suggestionsContainer && this.suggestionsContainer.nativeElement.contains(relatedTarget) || pacContainer && pacContainer.contains(relatedTarget)) return;\n      this.showSuggestions = false;\n    }, 150);\n  }\n\n  initializeSkillsInput() {\n    const tagInput = this.document.getElementById('tagInput');\n    const tagContainer = this.document.getElementById('tagContainer');\n    const skillsSuggestionsDiv = this.document.getElementById('skillsSuggestions');\n\n    if (!tagInput || !tagContainer || !skillsSuggestionsDiv) {\n      if (this.isViewInitialized) console.warn('Skill input elements not found!');\n      return;\n    }\n\n    let activeSuggestionIndex = -1;\n\n    const showAvailableSuggestions = suggestedSkills => {\n      skillsSuggestionsDiv.innerHTML = '';\n\n      if (this.isLoadingSkills && suggestedSkills.length === 0 && tagInput.value.trim()) {\n        const item = this.renderer.createElement('div');\n        this.renderer.addClass(item, 'suggestion-item');\n        this.renderer.addClass(item, 'suggestion-loading');\n        item.textContent = 'Loading skills...';\n        this.renderer.appendChild(skillsSuggestionsDiv, item);\n        skillsSuggestionsDiv.style.display = 'block';\n        return;\n      }\n\n      if (suggestedSkills.length === 0) {\n        if (tagInput.value.trim()) {\n          const item = this.renderer.createElement('div');\n          this.renderer.addClass(item, 'suggestion-item');\n          this.renderer.addClass(item, 'no-results');\n          item.textContent = 'No matching skills found.';\n          this.renderer.appendChild(skillsSuggestionsDiv, item);\n          skillsSuggestionsDiv.style.display = 'block';\n        } else {\n          skillsSuggestionsDiv.style.display = 'none';\n        }\n\n        return;\n      }\n\n      suggestedSkills.forEach(skillName => {\n        const item = this.renderer.createElement('div');\n        this.renderer.addClass(item, 'suggestion-item');\n        item.textContent = skillName;\n        this.renderer.listen(item, 'click', () => {\n          addSkillTag(skillName);\n          tagInput.value = '';\n          skillsSuggestionsDiv.style.display = 'none';\n          tagInput.focus();\n        });\n        this.renderer.appendChild(skillsSuggestionsDiv, item);\n      });\n      skillsSuggestionsDiv.style.display = 'block';\n      activeSuggestionIndex = -1;\n    };\n\n    const addSkillTag = skillName => {\n      var _a, _b, _c;\n\n      if (!skillName.trim()) return;\n      let currentSkills = ((_a = this.jobForm.get('skills')) === null || _a === void 0 ? void 0 : _a.value) || [];\n\n      if (currentSkills.includes(skillName)) {\n        this.snackBar.open(`Skill \"${skillName}\" is already added.`, 'Close', {\n          duration: 2000\n        });\n        return;\n      }\n\n      currentSkills = [...currentSkills, skillName];\n      this.jobForm.patchValue({\n        skills: currentSkills\n      });\n      (_b = this.jobForm.get('skills')) === null || _b === void 0 ? void 0 : _b.markAsDirty();\n      (_c = this.jobForm.get('skills')) === null || _c === void 0 ? void 0 : _c.updateValueAndValidity();\n      const tag = this.renderer.createElement('div');\n      this.renderer.addClass(tag, 'tag');\n      const tagText = this.renderer.createElement('span');\n      tagText.textContent = skillName;\n      this.renderer.appendChild(tag, tagText);\n      const removeBtn = this.renderer.createElement('button');\n      removeBtn.textContent = '×';\n      this.renderer.setAttribute(removeBtn, 'type', 'button');\n      this.renderer.listen(removeBtn, 'click', () => {\n        var _a, _b, _c;\n\n        this.renderer.removeChild(tagContainer, tag);\n        let skillsAfterRemove = ((_a = this.jobForm.get('skills')) === null || _a === void 0 ? void 0 : _a.value) || [];\n        skillsAfterRemove = skillsAfterRemove.filter(s => s !== skillName);\n        this.jobForm.patchValue({\n          skills: skillsAfterRemove\n        });\n        (_b = this.jobForm.get('skills')) === null || _b === void 0 ? void 0 : _b.markAsDirty();\n        (_c = this.jobForm.get('skills')) === null || _c === void 0 ? void 0 : _c.updateValueAndValidity();\n      });\n      this.renderer.appendChild(tag, removeBtn);\n      this.renderer.insertBefore(tagContainer, tag, tagInput);\n    };\n\n    const navigateAvailableSuggestions = direction => {\n      const items = skillsSuggestionsDiv.querySelectorAll('.suggestion-item:not(.suggestion-loading):not(.no-results)');\n      if (items.length === 0) return;\n      if (activeSuggestionIndex >= 0 && items[activeSuggestionIndex]) this.renderer.removeClass(items[activeSuggestionIndex], 'active-suggestion');\n      if (direction === 'down') activeSuggestionIndex = (activeSuggestionIndex + 1) % items.length;else activeSuggestionIndex = (activeSuggestionIndex - 1 + items.length) % items.length;\n\n      if (items[activeSuggestionIndex]) {\n        this.renderer.addClass(items[activeSuggestionIndex], 'active-suggestion');\n        items[activeSuggestionIndex].scrollIntoView({\n          block: 'nearest',\n          inline: 'nearest'\n        });\n      }\n    };\n\n    const skillInputSub = fromEvent(tagInput, 'input').pipe(map(event => event.target.value), debounceTime(this.SKILL_DEBOUNCE_DELAY), distinctUntilChanged(), tap(term => {\n      this.isLoadingSkills = !!term.trim();\n      if (!term.trim()) showAvailableSuggestions([]);\n    }), switchMap(term => {\n      if (!term.trim()) return of([]);\n      return this.skillService.searchSkills(term).pipe(map(apiSkills => apiSkills.map(s => s.name)), catchError(() => {\n        this.isLoadingSkills = false;\n        this.snackBar.open('Error fetching skills.', 'Close', {\n          duration: 3000\n        });\n        return of([]);\n      }));\n    })).subscribe(skillNames => {\n      var _a;\n\n      this.isLoadingSkills = false;\n      const currentSelectedSkills = ((_a = this.jobForm.get('skills')) === null || _a === void 0 ? void 0 : _a.value) || [];\n      const filteredForDisplay = skillNames.filter(name => !currentSelectedSkills.includes(name));\n      showAvailableSuggestions(filteredForDisplay.slice(0, 10));\n    });\n    this.subscriptions.add(skillInputSub);\n    tagInput.addEventListener('keydown', e => {\n      var _a, _b, _c;\n\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        const activeItem = skillsSuggestionsDiv.querySelector('.suggestion-item.active-suggestion');\n        if (activeItem && activeItem.textContent) addSkillTag(activeItem.textContent);else if (tagInput.value.trim()) addSkillTag(tagInput.value.trim());\n        tagInput.value = '';\n        skillsSuggestionsDiv.style.display = 'none';\n        activeSuggestionIndex = -1;\n      } else if (e.key === 'ArrowDown') {\n        e.preventDefault();\n        navigateAvailableSuggestions('down');\n      } else if (e.key === 'ArrowUp') {\n        e.preventDefault();\n        navigateAvailableSuggestions('up');\n      } else if (e.key === 'Backspace' && !tagInput.value) {\n        const currentSkills = ((_a = this.jobForm.get('skills')) === null || _a === void 0 ? void 0 : _a.value) || [];\n\n        if (currentSkills.length > 0) {\n          const tagsInDOM = tagContainer.querySelectorAll('.tag');\n          if (tagsInDOM.length > 0) this.renderer.removeChild(tagContainer, tagsInDOM[tagsInDOM.length - 1]);\n          currentSkills.pop();\n          this.jobForm.patchValue({\n            skills: currentSkills\n          });\n          (_b = this.jobForm.get('skills')) === null || _b === void 0 ? void 0 : _b.markAsDirty();\n          (_c = this.jobForm.get('skills')) === null || _c === void 0 ? void 0 : _c.updateValueAndValidity();\n        }\n      } else if (e.key === 'Escape') {\n        skillsSuggestionsDiv.style.display = 'none';\n        activeSuggestionIndex = -1;\n      }\n    });\n    this.document.addEventListener('click', e => {\n      const target = e.target;\n      if (!tagContainer.contains(target) && !skillsSuggestionsDiv.contains(target)) skillsSuggestionsDiv.style.display = 'none';\n    });\n    tagContainer.addEventListener('click', e => {\n      if (e.target === tagContainer) tagInput.focus();\n    });\n  }\n\n  onSubmit() {\n    this.jobForm.markAllAsTouched(); // Mark all fields including editor\n\n    this.checkEmpty('editor'); // Explicitly validate editor content on submit attempt\n\n    if (this.jobForm.invalid) {\n      this.snackBar.open('Please fill all required fields correctly.', 'Close', {\n        duration: 5000,\n        panelClass: ['error-snackbar']\n      });\n      const firstInvalidControl = Object.keys(this.jobForm.controls).find(key => this.jobForm.controls[key].invalid);\n\n      if (firstInvalidControl) {\n        let element = this.document.querySelector(`[formControlName=\"${firstInvalidControl}\"]`);\n\n        if (!element) {\n          if (firstInvalidControl === 'skills') element = this.document.getElementById('tagInput');else if (firstInvalidControl === 'job_description') element = this.document.getElementById('editor');\n        }\n\n        element === null || element === void 0 ? void 0 : element.scrollIntoView({\n          behavior: 'smooth',\n          block: 'center'\n        });\n      }\n\n      return;\n    }\n\n    const token = this.corporateAuthService.getJWTToken();\n\n    if (!token) {\n      this.snackBar.open('Authentication required. Please log in.', 'Close', {\n        duration: 5000\n      });\n      this.router.navigate(['/login-corporate']);\n      return;\n    }\n\n    this.isSubmitting = true;\n\n    if (this.currentStep === 'jobPost') {\n      const formValues = this.jobForm.getRawValue();\n      const jobDetails = Object.assign(Object.assign({}, formValues), {\n        skills: {\n          primary: (formValues.skills || []).slice(0, Math.ceil((formValues.skills || []).length / 2)).map(s => ({\n            skill: s,\n            skill_confidence: 0.9,\n            type_confidence: 0.9\n          })),\n          secondary: (formValues.skills || []).slice(Math.ceil((formValues.skills || []).length / 2)).map(s => ({\n            skill: s,\n            skill_confidence: 0.8,\n            type_confidence: 0.8\n          }))\n        },\n        status: 'draft'\n      });\n      const saveSub = this.jobDescriptionService.saveJobPost(jobDetails, token).subscribe({\n        next: response => {\n          this.isSubmitting = false;\n          this.snackBar.open('Job post saved. Proceeding to assessment.', 'Close', {\n            duration: 3000\n          });\n          this.jobForm.patchValue({\n            unique_id: response.unique_id\n          });\n          this.currentStep = 'assessment';\n        },\n        error: error => {\n          this.isSubmitting = false;\n          console.error('Job post saving failed:', error);\n          this.snackBar.open(`Job post saving failed: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`, 'Close', {\n            duration: 5000\n          });\n        }\n      });\n      this.subscriptions.add(saveSub);\n    } else if (this.currentStep === 'assessment') {\n      // console.log('Submitting assessment for job unique_id:', this.jobForm.get('unique_id')?.value);\n      setTimeout(() => {\n        this.isSubmitting = false;\n        this.snackBar.open('Assessment details submitted!', 'Close', {\n          duration: 3000\n        });\n        this.resetForm();\n        this.router.navigate(['/job-posted']);\n      }, 1500);\n    }\n  }\n\n  onCancel() {\n    if (this.currentStep === 'assessment') {\n      this.snackBar.open('Returning to job post editing.', 'Close', {\n        duration: 2000\n      });\n      this.currentStep = 'jobPost';\n    } else {\n      this.snackBar.open('Job post creation cancelled.', 'Close', {\n        duration: 3000\n      });\n      this.resetForm();\n      this.router.navigate(['/dashboard']);\n    }\n  }\n\n  resetForm() {\n    this.jobForm.reset({\n      role: '',\n      location: '',\n      job_type: '',\n      workplace_type: '',\n      total_experience_min: 0,\n      total_experience_max: 30,\n      relevant_experience_min: 0,\n      relevant_experience_max: 30,\n      budget_type: '',\n      min_budget: null,\n      max_budget: null,\n      notice_period: '',\n      skills: [],\n      job_description: '',\n      job_description_url: '',\n      unique_id: ''\n    });\n    this.clearFileInput();\n    this.isFileUploadCompletedSuccessfully = false;\n\n    if (this.isViewInitialized) {\n      this.populateSkills([]);\n      this.setJobDescription('');\n      this.updateExperienceUI();\n    }\n\n    this.currentStep = 'jobPost';\n    this.jobData = null;\n    this.isSubmitting = false;\n    this.isLoadingSkills = false;\n\n    if (this.currentStep === 'jobPost' && this.isViewInitialized && this.locationInput && this.locationInput.nativeElement) {\n      this.locationInput.nativeElement.value = ''; // Re-initialize location services if needed, or ensure autocomplete is cleared/reset\n      // For example, if this.autocomplete exists, you might want to unbind it or clear its input.\n      // For now, just clearing the input value.\n    }\n  }\n\n  ngOnDestroy() {\n    this.subscriptions.unsubscribe(); // Clean up all subscriptions\n    // Clean up Google Maps Autocomplete instance and its listeners if it exists\n\n    if (this.autocomplete) {// google.maps.event.clearInstanceListeners(this.autocomplete); // Deprecated way\n      // New way: Autocomplete instance itself doesn't have a direct 'destroy' or 'clear listeners'.\n      // It's usually enough to let it be garbage collected once no references exist.\n      // If the input element it's attached to is removed from DOM, that also helps.\n      // For good measure, if you had specific listeners on the input element for autocomplete, clear them.\n      // If the locationInput element itself is part of this component and gets destroyed, that's usually sufficient.\n    } // Clean up dynamically added event listeners on document (if any were not auto-cleaned by Angular)\n    // The listeners on markers in initializeRange are on elements within the component's template,\n    // so Angular should handle their cleanup. The document listeners for mousemove/mouseup\n    // are removed in onMouseUp, which is good.\n    // The document listener for skills input click outside is okay as long as the component is destroyed.\n    // However, it's best practice to remove document listeners explicitly in ngOnDestroy.\n    // Example: (this requires storing the listener function)\n    // this.document.removeEventListener('click', this.boundHideSkillSuggestionsOnClickOutside);\n\n  }\n\n};\n\n__decorate([ViewChild('locationInput')], CreateJobPost1stPageComponent.prototype, \"locationInput\", void 0);\n\n__decorate([ViewChild('suggestionsContainer')], CreateJobPost1stPageComponent.prototype, \"suggestionsContainer\", void 0);\n\n__decorate([ViewChild('fileInput')], CreateJobPost1stPageComponent.prototype, \"fileInput\", void 0);\n\nCreateJobPost1stPageComponent = __decorate([Component({\n  selector: 'create-job-post-1st-page',\n  templateUrl: './create-job-post-1st-page.component.html',\n  styleUrls: ['./create-job-post-1st-page.component.css']\n}), __param(10, Inject(DOCUMENT))], CreateJobPost1stPageComponent);\nexport { CreateJobPost1stPageComponent };","map":null,"metadata":{},"sourceType":"module"}